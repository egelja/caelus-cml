; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT pdata
; File c:\users\darrin\downloads\zlib127\zlib-1.2.7\adler32.c
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+196
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 140  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4d 8b d0	 mov	 r10, r8
  00008	8b da		 mov	 ebx, edx
  0000a	44 8b d9	 mov	 r11d, ecx

; 141  :     unsigned long sum1;
; 142  :     unsigned long sum2;
; 143  :     unsigned rem;
; 144  : 
; 145  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 146  :     if (len2 < 0)

  0000d	4d 85 c0	 test	 r8, r8
  00010	79 09		 jns	 SHORT $LN5@adler32_co

; 147  :         return 0xffffffffUL;

  00012	83 c8 ff	 or	 eax, -1			; ffffffffH

; 161  :     return sum1 | (sum2 << 16);
; 162  : }

  00015	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0001a	c3		 ret	 0
$LN5@adler32_co:

; 148  : 
; 149  :     /* the derivation of this formula is left as an exercise for the reader */
; 150  :     MOD63(len2);                /* assumes len2 >= 0 */
; 151  :     rem = (unsigned)len2;
; 152  :     sum1 = adler1 & 0xffff;
; 153  :     sum2 = rem * sum1;
; 154  :     MOD(sum2);
; 155  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 156  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  0001b	41 c1 eb 10	 shr	 r11d, 16
  0001f	0f b7 c9	 movzx	 ecx, cx
  00022	48 b8 e7 e2 97
	86 70 80 07 80	 mov	 rax, -9221260491235007769 ; 800780708697e2e7H
  0002c	49 f7 ea	 imul	 r10
  0002f	49 03 d0	 add	 rdx, r8
  00032	44 8b c1	 mov	 r8d, ecx
  00035	48 c1 fa 0f	 sar	 rdx, 15
  00039	48 8b c2	 mov	 rax, rdx
  0003c	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00040	48 03 d0	 add	 rdx, rax
  00043	0f b7 c3	 movzx	 eax, bx
  00046	c1 eb 10	 shr	 ebx, 16
  00049	44 8d 8c 01 f0
	ff 00 00	 lea	 r9d, DWORD PTR [rcx+rax+65520]
  00051	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00056	69 d2 f1 ff 00
	00		 imul	 edx, 65521		; 0000fff1H
  0005c	44 2b d2	 sub	 r10d, edx
  0005f	45 0f af c2	 imul	 r8d, r10d
  00063	41 f7 e0	 mul	 r8d
  00066	c1 ea 0f	 shr	 edx, 15
  00069	69 d2 f1 ff 00
	00		 imul	 edx, 65521		; 0000fff1H
  0006f	44 2b da	 sub	 r11d, edx
  00072	44 03 db	 add	 r11d, ebx
  00075	45 2b da	 sub	 r11d, r10d
  00078	43 8d 84 18 f1
	ff 00 00	 lea	 eax, DWORD PTR [r8+r11+65521]

; 157  :     if (sum1 >= BASE) sum1 -= BASE;

  00080	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00087	72 17		 jb	 SHORT $LN3@adler32_co
  00089	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH

; 158  :     if (sum1 >= BASE) sum1 -= BASE;

  00090	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00097	72 07		 jb	 SHORT $LN3@adler32_co
  00099	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH
$LN3@adler32_co:

; 159  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  000a0	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  000a5	72 05		 jb	 SHORT $LN2@adler32_co
  000a7	05 1e 00 fe ff	 add	 eax, -131042		; fffe001eH
$LN2@adler32_co:

; 160  :     if (sum2 >= BASE) sum2 -= BASE;

  000ac	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  000b1	72 05		 jb	 SHORT $LN1@adler32_co
  000b3	05 0f 00 ff ff	 add	 eax, -65521		; ffff000fH
$LN1@adler32_co:

; 161  :     return sum1 | (sum2 << 16);
; 162  : }

  000b8	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000bd	c1 e0 10	 shl	 eax, 16
  000c0	41 0b c1	 or	 eax, r9d
  000c3	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
PUBLIC	adler32
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32 DD imagerel $LN32
	DD	imagerel $LN32+193
	DD	imagerel $unwind$adler32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$adler32 DD imagerel $LN32+193
	DD	imagerel $LN32+464
	DD	imagerel $chain$0$adler32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$adler32 DD imagerel $LN32+464
	DD	imagerel $LN32+777
	DD	imagerel $chain$1$adler32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$adler32 DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+193
	DD	imagerel $unwind$adler32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$adler32 DD 020421H
	DD	03404H
	DD	imagerel $LN32
	DD	imagerel $LN32+193
	DD	imagerel $unwind$adler32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32 DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 16
buf$ = 24
len$ = 32
adler32	PROC						; COMDAT

; 69   : {

$LN32:
  00000	48 83 ec 08	 sub	 rsp, 8

; 70   :     unsigned long sum2;
; 71   :     unsigned n;
; 72   : 
; 73   :     /* split Adler-32 into component sums */
; 74   :     sum2 = (adler >> 16) & 0xffff;

  00004	44 8b d1	 mov	 r10d, ecx
  00007	4c 8b da	 mov	 r11, rdx

; 75   :     adler &= 0xffff;

  0000a	44 0f b7 c9	 movzx	 r9d, cx
  0000e	41 c1 ea 10	 shr	 r10d, 16

; 76   : 
; 77   :     /* in case user likes doing a byte at a time, keep it fast */
; 78   :     if (len == 1) {

  00012	41 83 f8 01	 cmp	 r8d, 1
  00016	75 3c		 jne	 SHORT $LN18@adler32

; 79   :         adler += buf[0];

  00018	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0001b	44 03 c8	 add	 r9d, eax

; 80   :         if (adler >= BASE)

  0001e	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00025	72 07		 jb	 SHORT $LN17@adler32

; 81   :             adler -= BASE;

  00027	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH
$LN17@adler32:

; 82   :         sum2 += adler;

  0002e	45 03 d1	 add	 r10d, r9d

; 83   :         if (sum2 >= BASE)

  00031	41 81 fa f1 ff
	00 00		 cmp	 r10d, 65521		; 0000fff1H
  00038	0f 82 bc 02 00
	00		 jb	 $LN5@adler32

; 84   :             sum2 -= BASE;

  0003e	41 81 c2 0f 00
	ff ff		 add	 r10d, -65521		; ffff000fH

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  00045	41 c1 e2 10	 shl	 r10d, 16
  00049	45 0b d1	 or	 r10d, r9d
  0004c	41 8b c2	 mov	 eax, r10d

; 133  : }

  0004f	48 83 c4 08	 add	 rsp, 8
  00053	c3		 ret	 0
$LN18@adler32:

; 85   :         return adler | (sum2 << 16);
; 86   :     }
; 87   : 
; 88   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 89   :     if (buf == Z_NULL)

  00054	48 85 d2	 test	 rdx, rdx
  00057	75 08		 jne	 SHORT $LN15@adler32

; 90   :         return 1L;

  00059	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 133  : }

  0005c	48 83 c4 08	 add	 rsp, 8
  00060	c3		 ret	 0
$LN15@adler32:

; 91   : 
; 92   :     /* in case short lengths are provided, keep it somewhat fast */
; 93   :     if (len < 16) {

  00061	41 83 f8 10	 cmp	 r8d, 16
  00065	73 48		 jae	 SHORT $LN22@adler32

; 94   :         while (len--) {

  00067	45 85 c0	 test	 r8d, r8d
  0006a	74 16		 je	 SHORT $LN26@adler32
  0006c	0f 1f 40 00	 npad	 4
$LL13@adler32:

; 95   :             adler += *buf++;

  00070	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]
  00074	49 ff c3	 inc	 r11
  00077	44 03 c8	 add	 r9d, eax

; 96   :             sum2 += adler;

  0007a	45 03 d1	 add	 r10d, r9d
  0007d	41 ff c8	 dec	 r8d
  00080	75 ee		 jne	 SHORT $LL13@adler32
$LN26@adler32:

; 97   :         }
; 98   :         if (adler >= BASE)

  00082	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00089	72 07		 jb	 SHORT $LN11@adler32

; 99   :             adler -= BASE;

  0008b	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH
$LN11@adler32:

; 100  :         MOD28(sum2);            /* only added so many BASE's */

  00092	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00097	41 f7 e2	 mul	 r10d
  0009a	c1 ea 0f	 shr	 edx, 15

; 101  :         return adler | (sum2 << 16);

  0009d	6b d2 0f	 imul	 edx, 15
  000a0	41 8d 04 12	 lea	 eax, DWORD PTR [r10+rdx]
  000a4	c1 e0 10	 shl	 eax, 16
  000a7	41 0b c1	 or	 eax, r9d

; 133  : }

  000aa	48 83 c4 08	 add	 rsp, 8
  000ae	c3		 ret	 0
$LN22@adler32:

; 102  :     }
; 103  : 
; 104  :     /* do length NMAX blocks -- requires just one modulo operation */
; 105  :     while (len >= NMAX) {

  000af	41 81 f8 b0 15
	00 00		 cmp	 r8d, 5552		; 000015b0H
  000b6	0f 82 14 01 00
	00		 jb	 $LN9@adler32
  000bc	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  000c1	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  000c5	41 f7 e0	 mul	 r8d
  000c8	c1 ea 0b	 shr	 edx, 11
  000cb	8b da		 mov	 ebx, edx
  000cd	0f 1f 00	 npad	 3
$LL10@adler32:

; 106  :         len -= NMAX;

  000d0	41 81 c0 50 ea
	ff ff		 add	 r8d, -5552		; ffffea50H

; 107  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000d7	b9 5b 01 00 00	 mov	 ecx, 347		; 0000015bH
  000dc	0f 1f 40 00	 npad	 4
$LL8@adler32:

; 108  :         do {
; 109  :             DO16(buf);          /* 16 sums unrolled */

  000e0	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]

; 110  :             buf += 16;

  000e4	49 83 c3 10	 add	 r11, 16
  000e8	44 03 c8	 add	 r9d, eax
  000eb	41 0f b6 43 f1	 movzx	 eax, BYTE PTR [r11-15]
  000f0	45 03 d1	 add	 r10d, r9d
  000f3	44 03 c8	 add	 r9d, eax
  000f6	41 0f b6 43 f2	 movzx	 eax, BYTE PTR [r11-14]
  000fb	45 03 d1	 add	 r10d, r9d
  000fe	44 03 c8	 add	 r9d, eax
  00101	41 0f b6 43 f3	 movzx	 eax, BYTE PTR [r11-13]
  00106	45 03 d1	 add	 r10d, r9d
  00109	44 03 c8	 add	 r9d, eax
  0010c	41 0f b6 43 f4	 movzx	 eax, BYTE PTR [r11-12]
  00111	45 03 d1	 add	 r10d, r9d
  00114	44 03 c8	 add	 r9d, eax
  00117	41 0f b6 43 f5	 movzx	 eax, BYTE PTR [r11-11]
  0011c	45 03 d1	 add	 r10d, r9d
  0011f	44 03 c8	 add	 r9d, eax
  00122	41 0f b6 43 f6	 movzx	 eax, BYTE PTR [r11-10]
  00127	45 03 d1	 add	 r10d, r9d
  0012a	44 03 c8	 add	 r9d, eax
  0012d	41 0f b6 43 f7	 movzx	 eax, BYTE PTR [r11-9]
  00132	45 03 d1	 add	 r10d, r9d
  00135	44 03 c8	 add	 r9d, eax
  00138	41 0f b6 43 f8	 movzx	 eax, BYTE PTR [r11-8]
  0013d	45 03 d1	 add	 r10d, r9d
  00140	44 03 c8	 add	 r9d, eax
  00143	41 0f b6 43 f9	 movzx	 eax, BYTE PTR [r11-7]
  00148	45 03 d1	 add	 r10d, r9d
  0014b	44 03 c8	 add	 r9d, eax
  0014e	41 0f b6 43 fa	 movzx	 eax, BYTE PTR [r11-6]
  00153	45 03 d1	 add	 r10d, r9d
  00156	44 03 c8	 add	 r9d, eax
  00159	41 0f b6 43 fb	 movzx	 eax, BYTE PTR [r11-5]
  0015e	45 03 d1	 add	 r10d, r9d
  00161	44 03 c8	 add	 r9d, eax
  00164	41 0f b6 43 fc	 movzx	 eax, BYTE PTR [r11-4]
  00169	45 03 d1	 add	 r10d, r9d
  0016c	44 03 c8	 add	 r9d, eax
  0016f	41 0f b6 43 fd	 movzx	 eax, BYTE PTR [r11-3]
  00174	45 03 d1	 add	 r10d, r9d
  00177	44 03 c8	 add	 r9d, eax
  0017a	41 0f b6 43 fe	 movzx	 eax, BYTE PTR [r11-2]
  0017f	45 03 d1	 add	 r10d, r9d
  00182	44 03 c8	 add	 r9d, eax
  00185	41 0f b6 43 ff	 movzx	 eax, BYTE PTR [r11-1]
  0018a	45 03 d1	 add	 r10d, r9d
  0018d	44 03 c8	 add	 r9d, eax
  00190	45 03 d1	 add	 r10d, r9d

; 111  :         } while (--n);

  00193	ff c9		 dec	 ecx
  00195	0f 85 45 ff ff
	ff		 jne	 $LL8@adler32

; 112  :         MOD(adler);

  0019b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  001a0	41 f7 e1	 mul	 r9d

; 113  :         MOD(sum2);

  001a3	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  001a8	c1 ea 0f	 shr	 edx, 15
  001ab	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  001b1	44 03 ca	 add	 r9d, edx
  001b4	41 f7 e2	 mul	 r10d
  001b7	c1 ea 0f	 shr	 edx, 15
  001ba	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  001c0	44 03 d2	 add	 r10d, edx
  001c3	48 ff cb	 dec	 rbx
  001c6	0f 85 04 ff ff
	ff		 jne	 $LL10@adler32
  001cc	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN9@adler32:

; 114  :     }
; 115  : 
; 116  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 117  :     if (len) {                  /* avoid modulos if none remaining */

  001d0	45 85 c0	 test	 r8d, r8d
  001d3	0f 84 21 01 00
	00		 je	 $LN5@adler32

; 118  :         while (len >= 16) {

  001d9	41 83 f8 10	 cmp	 r8d, 16
  001dd	0f 82 cd 00 00
	00		 jb	 $LN25@adler32
  001e3	41 8b c8	 mov	 ecx, r8d
  001e6	48 c1 e9 04	 shr	 rcx, 4
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL4@adler32:

; 119  :             len -= 16;
; 120  :             DO16(buf);

  001f0	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]
  001f4	41 83 c0 f0	 add	 r8d, -16		; fffffff0H

; 121  :             buf += 16;

  001f8	49 83 c3 10	 add	 r11, 16
  001fc	44 03 c8	 add	 r9d, eax
  001ff	41 0f b6 43 f1	 movzx	 eax, BYTE PTR [r11-15]
  00204	45 03 d1	 add	 r10d, r9d
  00207	44 03 c8	 add	 r9d, eax
  0020a	41 0f b6 43 f2	 movzx	 eax, BYTE PTR [r11-14]
  0020f	45 03 d1	 add	 r10d, r9d
  00212	44 03 c8	 add	 r9d, eax
  00215	41 0f b6 43 f3	 movzx	 eax, BYTE PTR [r11-13]
  0021a	45 03 d1	 add	 r10d, r9d
  0021d	44 03 c8	 add	 r9d, eax
  00220	41 0f b6 43 f4	 movzx	 eax, BYTE PTR [r11-12]
  00225	45 03 d1	 add	 r10d, r9d
  00228	44 03 c8	 add	 r9d, eax
  0022b	41 0f b6 43 f5	 movzx	 eax, BYTE PTR [r11-11]
  00230	45 03 d1	 add	 r10d, r9d
  00233	44 03 c8	 add	 r9d, eax
  00236	41 0f b6 43 f6	 movzx	 eax, BYTE PTR [r11-10]
  0023b	45 03 d1	 add	 r10d, r9d
  0023e	44 03 c8	 add	 r9d, eax
  00241	41 0f b6 43 f7	 movzx	 eax, BYTE PTR [r11-9]
  00246	45 03 d1	 add	 r10d, r9d
  00249	44 03 c8	 add	 r9d, eax
  0024c	41 0f b6 43 f8	 movzx	 eax, BYTE PTR [r11-8]
  00251	45 03 d1	 add	 r10d, r9d
  00254	44 03 c8	 add	 r9d, eax
  00257	41 0f b6 43 f9	 movzx	 eax, BYTE PTR [r11-7]
  0025c	45 03 d1	 add	 r10d, r9d
  0025f	44 03 c8	 add	 r9d, eax
  00262	41 0f b6 43 fa	 movzx	 eax, BYTE PTR [r11-6]
  00267	45 03 d1	 add	 r10d, r9d
  0026a	44 03 c8	 add	 r9d, eax
  0026d	41 0f b6 43 fb	 movzx	 eax, BYTE PTR [r11-5]
  00272	45 03 d1	 add	 r10d, r9d
  00275	44 03 c8	 add	 r9d, eax
  00278	41 0f b6 43 fc	 movzx	 eax, BYTE PTR [r11-4]
  0027d	45 03 d1	 add	 r10d, r9d
  00280	44 03 c8	 add	 r9d, eax
  00283	41 0f b6 43 fd	 movzx	 eax, BYTE PTR [r11-3]
  00288	45 03 d1	 add	 r10d, r9d
  0028b	44 03 c8	 add	 r9d, eax
  0028e	41 0f b6 43 fe	 movzx	 eax, BYTE PTR [r11-2]
  00293	45 03 d1	 add	 r10d, r9d
  00296	44 03 c8	 add	 r9d, eax
  00299	41 0f b6 43 ff	 movzx	 eax, BYTE PTR [r11-1]
  0029e	45 03 d1	 add	 r10d, r9d
  002a1	44 03 c8	 add	 r9d, eax
  002a4	45 03 d1	 add	 r10d, r9d
  002a7	48 ff c9	 dec	 rcx
  002aa	0f 85 40 ff ff
	ff		 jne	 $LL4@adler32
$LN25@adler32:

; 122  :         }
; 123  :         while (len--) {

  002b0	45 85 c0	 test	 r8d, r8d
  002b3	74 1d		 je	 SHORT $LN30@adler32
  002b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@adler32:

; 124  :             adler += *buf++;

  002c0	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]
  002c4	49 ff c3	 inc	 r11
  002c7	44 03 c8	 add	 r9d, eax

; 125  :             sum2 += adler;

  002ca	45 03 d1	 add	 r10d, r9d
  002cd	41 ff c8	 dec	 r8d
  002d0	75 ee		 jne	 SHORT $LL2@adler32
$LN30@adler32:

; 126  :         }
; 127  :         MOD(adler);

  002d2	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002d7	41 f7 e1	 mul	 r9d

; 128  :         MOD(sum2);

  002da	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002df	c1 ea 0f	 shr	 edx, 15
  002e2	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  002e8	44 03 ca	 add	 r9d, edx
  002eb	41 f7 e2	 mul	 r10d
  002ee	c1 ea 0f	 shr	 edx, 15
  002f1	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  002f7	44 03 d2	 add	 r10d, edx
$LN5@adler32:

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  002fa	41 c1 e2 10	 shl	 r10d, 16
  002fe	45 0b d1	 or	 r10d, r9d
  00301	41 8b c2	 mov	 eax, r10d

; 133  : }

  00304	48 83 c4 08	 add	 rsp, 8
  00308	c3		 ret	 0
adler32	ENDP
PUBLIC	adler32_combine
; Function compile flags: /Ogtpy
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 170  :     return adler32_combine_(adler1, adler2, len2);

  00000	4d 63 c0	 movsxd	 r8, r8d

; 171  : }

  00003	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
END
