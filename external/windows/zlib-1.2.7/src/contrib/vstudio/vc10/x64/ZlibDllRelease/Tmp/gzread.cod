; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp_memchr:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_close:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
PUBLIC	gzclose_r
;	COMDAT pdata
; File c:\users\darrin\downloads\zlib127\zlib-1.2.7\gzread.c
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN7
	DD	imagerel $LN7+161
	DD	imagerel $unwind$gzclose_r
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 063001H
	DD	077430H
	DD	06342bH
	DD	060023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzclose_r
_TEXT	SEGMENT
file$ = 48
gzclose_r PROC						; COMDAT

; 564  : {

$LN7:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 565  :     int ret, err;
; 566  :     gz_statep state;
; 567  : 
; 568  :     /* get internal structure */
; 569  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0b		 jne	 SHORT $LN3@gzclose_r
$LN6@gzclose_r:

; 570  :         return Z_STREAM_ERROR;

  0000e	b8 fe ff ff ff	 mov	 eax, -2

; 589  : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5e		 pop	 rsi
  00018	c3		 ret	 0
$LN3@gzclose_r:

; 571  :     state = (gz_statep)file;
; 572  : 
; 573  :     /* check that we're reading */
; 574  :     if (state->mode != GZ_READ)

  00019	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH

; 575  :         return Z_STREAM_ERROR;

  00020	75 ec		 jne	 SHORT $LN6@gzclose_r

; 576  : 
; 577  :     /* free memory and close file */
; 578  :     if (state->size) {

  00022	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00030	74 1d		 je	 SHORT $LN1@gzclose_r

; 579  :         inflateEnd(&(state->strm));

  00032	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00036	e8 00 00 00 00	 call	 inflateEnd

; 580  :         free(state->out);

  0003b	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 581  :         free(state->in);

  00045	48 8b 4e 30	 mov	 rcx, QWORD PTR [rsi+48]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@gzclose_r:

; 582  :     }
; 583  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  0004f	b8 fb ff ff ff	 mov	 eax, -5
  00054	33 ff		 xor	 edi, edi

; 584  :     gz_error(state, Z_OK, NULL);

  00056	48 8b ce	 mov	 rcx, rsi
  00059	39 46 6c	 cmp	 DWORD PTR [rsi+108], eax
  0005c	0f 44 f8	 cmove	 edi, eax
  0005f	45 33 c0	 xor	 r8d, r8d
  00062	33 d2		 xor	 edx, edx
  00064	e8 00 00 00 00	 call	 gz_error

; 585  :     free(state->path);

  00069	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 586  :     ret = close(state->fd);

  00073	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 587  :     free(state);

  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	8b d8		 mov	 ebx, eax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 588  :     return ret ? Z_ERRNO : err;

  00087	83 c8 ff	 or	 eax, -1
  0008a	85 db		 test	 ebx, ebx
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	0f 45 f8	 cmovne	 edi, eax
  00094	8b c7		 mov	 eax, edi
  00096	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 589  : }

  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5e		 pop	 rsi
  000a0	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+149
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_load
_TEXT	SEGMENT
state$ = 48
buf$ = 56
len$ = 64
have$ = 72
gz_load	PROC						; COMDAT

; 25   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b d9	 mov	 rbx, r9
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 26   :     int ret;
; 27   : 
; 28   :     *have = 0;

  00020	41 c7 01 00 00
	00 00		 mov	 DWORD PTR [r9], 0
  00027	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@gz_load:

; 29   :     do {
; 30   :         ret = read(state->fd, buf + *have, len - *have);

  00030	8b 13		 mov	 edx, DWORD PTR [rbx]
  00032	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00035	44 8b c7	 mov	 r8d, edi
  00038	44 2b c2	 sub	 r8d, edx
  0003b	48 03 d5	 add	 rdx, rbp
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 31   :         if (ret <= 0)

  00044	85 c0		 test	 eax, eax
  00046	7e 08		 jle	 SHORT $LN11@gz_load

; 32   :             break;
; 33   :         *have += ret;

  00048	01 03		 add	 DWORD PTR [rbx], eax

; 34   :     } while (*have < len);

  0004a	39 3b		 cmp	 DWORD PTR [rbx], edi
  0004c	72 e2		 jb	 SHORT $LL6@gz_load

; 35   :     if (ret < 0) {

  0004e	85 c0		 test	 eax, eax
$LN11@gz_load:
  00050	79 21		 jns	 SHORT $LN2@gz_load

; 36   :         gz_error(state, Z_ERRNO, zstrerror());

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00058	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00060	83 ca ff	 or	 edx, -1
  00063	48 8b ce	 mov	 rcx, rsi
  00066	4c 8b c0	 mov	 r8, rax
  00069	e8 00 00 00 00	 call	 gz_error

; 37   :         return -1;

  0006e	83 c8 ff	 or	 eax, -1
  00071	eb 0d		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 38   :     }
; 39   :     if (ret == 0)

  00073	85 c0		 test	 eax, eax
  00075	75 07		 jne	 SHORT $LN1@gz_load

; 40   :         state->eof = 1;

  00077	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [rsi+80], 1
$LN1@gz_load:

; 41   :     return 0;

  0007e	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 42   : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
gz_load	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+142
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_avail
_TEXT	SEGMENT
got$ = 48
state$ = 48
gz_avail PROC						; COMDAT

; 53   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 54   :     unsigned got;
; 55   :     z_streamp strm = &(state->strm);
; 56   : 
; 57   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00006	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	85 c0		 test	 eax, eax
  0000e	74 0e		 je	 SHORT $LN7@gz_avail
  00010	83 f8 fb	 cmp	 eax, -5
  00013	74 09		 je	 SHORT $LN7@gz_avail
$LN11@gz_avail:

; 58   :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 74   : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN7@gz_avail:

; 59   :     if (state->eof == 0) {

  0001e	83 79 50 00	 cmp	 DWORD PTR [rcx+80], 0
  00022	75 62		 jne	 SHORT $LN6@gz_avail

; 60   :         if (strm->avail_in) {       /* copy what's there to the start */

  00024	44 8b 81 80 00
	00 00		 mov	 r8d, DWORD PTR [rcx+128]
  0002b	45 85 c0	 test	 r8d, r8d
  0002e	74 21		 je	 SHORT $LN2@gz_avail

; 61   :             unsigned char *p = state->in, *q = strm->next_in;

  00030	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00034	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gz_avail:

; 62   :             unsigned n = strm->avail_in;
; 63   :             do {
; 64   :                 *p++ = *q++;

  00040	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00043	48 ff c1	 inc	 rcx
  00046	48 ff c2	 inc	 rdx

; 65   :             } while (--n);

  00049	41 ff c8	 dec	 r8d
  0004c	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0004f	75 ef		 jne	 SHORT $LL4@gz_avail
$LN2@gz_avail:

; 66   :         }
; 67   :         if (gz_load(state, state->in + strm->avail_in,
; 68   :                     state->size - strm->avail_in, &got) == -1)

  00051	8b 93 80 00 00
	00		 mov	 edx, DWORD PTR [rbx+128]
  00057	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0005b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR got$[rsp]
  00060	44 2b c2	 sub	 r8d, edx
  00063	48 03 53 30	 add	 rdx, QWORD PTR [rbx+48]
  00067	48 8b cb	 mov	 rcx, rbx
  0006a	e8 00 00 00 00	 call	 gz_load
  0006f	83 f8 ff	 cmp	 eax, -1

; 69   :             return -1;

  00072	74 a1		 je	 SHORT $LN11@gz_avail

; 70   :         strm->avail_in += got;

  00074	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
  00078	01 83 80 00 00
	00		 add	 DWORD PTR [rbx+128], eax

; 71   :         strm->next_in = state->in;

  0007e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00082	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN6@gz_avail:

; 72   :     }
; 73   :     return 0;

  00086	33 c0		 xor	 eax, eax

; 74   : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5b		 pop	 rbx
  0008d	c3		 ret	 0
gz_avail ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+270
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_decomp
_TEXT	SEGMENT
state$ = 48
gz_decomp PROC						; COMDAT

; 173  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 174  :     int ret = Z_OK;
; 175  :     unsigned had;
; 176  :     z_streamp strm = &(state->strm);
; 177  : 
; 178  :     /* fill output buffer up to end of deflate stream */
; 179  :     had = strm->avail_out;

  00014	8b a9 90 00 00
	00		 mov	 ebp, DWORD PTR [rcx+144]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL11@gz_decomp:

; 180  :     do {
; 181  :         /* get more input for inflate() */
; 182  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00020	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00027	75 1a		 jne	 SHORT $LN22@gz_decomp
  00029	48 8b ce	 mov	 rcx, rsi
  0002c	e8 00 00 00 00	 call	 gz_avail
  00031	83 f8 ff	 cmp	 eax, -1
  00034	0f 84 bc 00 00
	00		 je	 $LN17@gz_decomp

; 183  :             return -1;
; 184  :         if (strm->avail_in == 0) {

  0003a	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00041	74 39		 je	 SHORT $LN18@gz_decomp
$LN22@gz_decomp:

; 186  :             break;
; 187  :         }
; 188  : 
; 189  :         /* decompress and handle errors */
; 190  :         ret = inflate(strm, Z_NO_FLUSH);

  00043	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00047	33 d2		 xor	 edx, edx
  00049	e8 00 00 00 00	 call	 inflate
  0004e	8b d8		 mov	 ebx, eax

; 191  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00050	83 f8 fe	 cmp	 eax, -2
  00053	0f 84 89 00 00
	00		 je	 $LN5@gz_decomp
  00059	83 f8 02	 cmp	 eax, 2
  0005c	0f 84 80 00 00
	00		 je	 $LN5@gz_decomp

; 195  :         }
; 196  :         if (ret == Z_MEM_ERROR) {

  00062	83 f8 fc	 cmp	 eax, -4
  00065	74 6d		 je	 SHORT $LN20@gz_decomp

; 199  :         }
; 200  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  00067	83 f8 fd	 cmp	 eax, -3
  0006a	74 4c		 je	 SHORT $LN21@gz_decomp

; 204  :         }
; 205  :     } while (strm->avail_out && ret != Z_STREAM_END);

  0006c	83 be 90 00 00
	00 00		 cmp	 DWORD PTR [rsi+144], 0
  00073	74 1b		 je	 SHORT $LN9@gz_decomp
  00075	83 f8 01	 cmp	 eax, 1
  00078	75 a6		 jne	 SHORT $LL11@gz_decomp
  0007a	eb 14		 jmp	 SHORT $LN9@gz_decomp
$LN18@gz_decomp:

; 185  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  00083	ba fb ff ff ff	 mov	 edx, -5
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	e8 00 00 00 00	 call	 gz_error
$LN9@gz_decomp:

; 206  : 
; 207  :     /* update available output */
; 208  :     state->x.have = had - strm->avail_out;

  00090	2b ae 90 00 00
	00		 sub	 ebp, DWORD PTR [rsi+144]
  00096	8b cd		 mov	 ecx, ebp
  00098	89 0e		 mov	 DWORD PTR [rsi], ecx

; 209  :     state->x.next = strm->next_out - state->x.have;

  0009a	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  000a1	48 2b c1	 sub	 rax, rcx
  000a4	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 210  : 
; 211  :     /* if the gzip stream completed successfully, look for another */
; 212  :     if (ret == Z_STREAM_END)

  000a8	83 fb 01	 cmp	 ebx, 1
  000ab	75 07		 jne	 SHORT $LN1@gz_decomp

; 213  :         state->how = LOOK;

  000ad	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [rsi+68], 0
$LN1@gz_decomp:

; 214  : 
; 215  :     /* good decompression */
; 216  :     return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 41		 jmp	 SHORT $LN12@gz_decomp
$LN21@gz_decomp:

; 201  :             gz_error(state, Z_DATA_ERROR,
; 202  :                      strm->msg == NULL ? "compressed data error" : strm->msg);

  000b8	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 85 c0	 test	 rax, rax
  000ce	4c 0f 45 c0	 cmovne	 r8, rax

; 203  :             return -1;

  000d2	eb 1a		 jmp	 SHORT $LN23@gz_decomp
$LN20@gz_decomp:

; 197  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000db	ba fc ff ff ff	 mov	 edx, -4

; 198  :             return -1;

  000e0	eb 0c		 jmp	 SHORT $LN23@gz_decomp
$LN5@gz_decomp:

; 192  :             gz_error(state, Z_STREAM_ERROR,
; 193  :                      "internal error: inflate stream corrupt");

  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  000e9	ba fe ff ff ff	 mov	 edx, -2
$LN23@gz_decomp:
  000ee	48 8b ce	 mov	 rcx, rsi
  000f1	e8 00 00 00 00	 call	 gz_error
$LN17@gz_decomp:

; 194  :             return -1;

  000f6	83 c8 ff	 or	 eax, -1
$LN12@gz_decomp:

; 217  : }

  000f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fe	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00103	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00108	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_look DD imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_look DD imagerel gz_look+40
	DD	imagerel gz_look+84
	DD	imagerel $chain$0$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_look DD imagerel gz_look+84
	DD	imagerel gz_look+457
	DD	imagerel $chain$1$gz_look
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_look DD 021H
	DD	imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_look DD 020521H
	DD	063405H
	DD	imagerel gz_look
	DD	imagerel gz_look+40
	DD	imagerel $unwind$gz_look
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_look DD 081501H
	DD	097415H
	DD	086415H
	DD	075415H
	DD	0c0113215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_look
_TEXT	SEGMENT
state$ = 48
gz_look	PROC						; COMDAT

; 87   : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 88   :     z_streamp strm = &(state->strm);
; 89   : 
; 90   :     /* allocate read buffers and inflate memory */
; 91   :     if (state->size == 0) {

  00015	45 33 e4	 xor	 r12d, r12d
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 39 61 28	 cmp	 DWORD PTR [rcx+40], r12d
  0001f	0f 85 e6 00 00
	00		 jne	 $LN7@gz_look

; 92   :         /* allocate buffers */
; 93   :         state->in = malloc(state->want);

  00025	8b 69 2c	 mov	 ebp, DWORD PTR [rcx+44]
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002d	8b cd		 mov	 ecx, ebp
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 94   :         state->out = malloc(state->want << 1);

  00035	8d 4c 2d 00	 lea	 ecx, DWORD PTR [rbp+rbp]
  00039	48 8b d8	 mov	 rbx, rax
  0003c	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 95   :         if (state->in == NULL || state->out == NULL) {

  00046	48 85 db	 test	 rbx, rbx
  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
  00052	74 7e		 je	 SHORT $LN10@gz_look
  00054	48 85 c0	 test	 rax, rax
  00057	0f 84 83 00 00
	00		 je	 $LN9@gz_look

; 102  :         }
; 103  :         state->size = state->want;
; 104  : 
; 105  :         /* allocate inflate memory */
; 106  :         state->strm.zalloc = Z_NULL;
; 107  :         state->strm.zfree = Z_NULL;
; 108  :         state->strm.opaque = Z_NULL;
; 109  :         state->strm.avail_in = 0;
; 110  :         state->strm.next_in = Z_NULL;
; 111  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  0005d	45 8d 4c 24 58	 lea	 r9d, QWORD PTR [r12+88]
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05HBMOAMF@1?42?47?$AA@
  00069	41 8d 54 24 1f	 lea	 edx, QWORD PTR [r12+31]
  0006e	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00072	89 6f 28	 mov	 DWORD PTR [rdi+40], ebp
  00075	4c 89 a7 a8 00
	00 00		 mov	 QWORD PTR [rdi+168], r12
  0007c	4c 89 a7 b0 00
	00 00		 mov	 QWORD PTR [rdi+176], r12
  00083	4c 89 a7 b8 00
	00 00		 mov	 QWORD PTR [rdi+184], r12
  0008a	44 89 a7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r12d
  00091	4c 89 67 78	 mov	 QWORD PTR [rdi+120], r12
  00095	e8 00 00 00 00	 call	 inflateInit2_
  0009a	85 c0		 test	 eax, eax
  0009c	74 6d		 je	 SHORT $LN7@gz_look

; 112  :             free(state->out);

  0009e	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 113  :             free(state->in);

  000a8	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 114  :             state->size = 0;
; 115  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000b9	41 8d 54 24 fc	 lea	 edx, QWORD PTR [r12-4]
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	44 89 67 28	 mov	 DWORD PTR [rdi+40], r12d
  000c5	e8 00 00 00 00	 call	 gz_error

; 116  :             return -1;

  000ca	83 c8 ff	 or	 eax, -1
  000cd	e9 e1 00 00 00	 jmp	 $LN13@gz_look
$LN10@gz_look:

; 96   :             if (state->out != NULL)

  000d2	48 85 c0	 test	 rax, rax
  000d5	74 09		 je	 SHORT $LN9@gz_look

; 97   :                 free(state->out);

  000d7	48 8b c8	 mov	 rcx, rax
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@gz_look:

; 98   :             if (state->in != NULL)

  000e0	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  000e4	48 85 c9	 test	 rcx, rcx
  000e7	74 06		 je	 SHORT $LN8@gz_look

; 99   :                 free(state->in);

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gz_look:

; 100  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000f6	ba fc ff ff ff	 mov	 edx, -4
  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 gz_error
$LN16@gz_look:

; 101  :             return -1;

  00103	83 c8 ff	 or	 eax, -1
  00106	e9 a8 00 00 00	 jmp	 $LN13@gz_look
$LN7@gz_look:

; 117  :         }
; 118  :     }
; 119  : 
; 120  :     /* get at least the magic bytes in the input buffer */
; 121  :     if (strm->avail_in < 2) {

  0010b	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00111	83 f8 02	 cmp	 eax, 2
  00114	73 1b		 jae	 SHORT $LN4@gz_look

; 122  :         if (gz_avail(state) == -1)

  00116	48 8b cf	 mov	 rcx, rdi
  00119	e8 00 00 00 00	 call	 gz_avail
  0011e	83 f8 ff	 cmp	 eax, -1

; 123  :             return -1;

  00121	74 e0		 je	 SHORT $LN16@gz_look

; 124  :         if (strm->avail_in == 0)

  00123	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00129	85 c0		 test	 eax, eax

; 125  :             return 0;

  0012b	0f 84 80 00 00
	00		 je	 $LN15@gz_look
$LN4@gz_look:

; 126  :     }
; 127  : 
; 128  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 129  :        a logical dilemma here when considering the case of a partially written
; 130  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 131  :        whether this is a single-byte file, or just a partially written gzip
; 132  :        file -- for here we assume that if a gzip file is being written, then
; 133  :        the header will be written in a single operation, so that reading a
; 134  :        single byte is sufficient indication that it is not a gzip file) */
; 135  :     if (strm->avail_in > 1 &&
; 136  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  00131	83 f8 01	 cmp	 eax, 1
  00134	76 25		 jbe	 SHORT $LN3@gz_look
  00136	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]
  0013a	80 38 1f	 cmp	 BYTE PTR [rax], 31
  0013d	75 1c		 jne	 SHORT $LN3@gz_look
  0013f	80 78 01 8b	 cmp	 BYTE PTR [rax+1], 139	; 0000008bH
  00143	75 16		 jne	 SHORT $LN3@gz_look

; 137  :         inflateReset(strm);

  00145	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00149	e8 00 00 00 00	 call	 inflateReset

; 138  :         state->how = GZIP;

  0014e	c7 47 44 02 00
	00 00		 mov	 DWORD PTR [rdi+68], 2

; 139  :         state->direct = 0;

  00155	44 89 67 40	 mov	 DWORD PTR [rdi+64], r12d

; 140  :         return 0;

  00159	eb 56		 jmp	 SHORT $LN15@gz_look
$LN3@gz_look:

; 141  :     }
; 142  : 
; 143  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 144  :        garbage.  Ignore the trailing garbage and finish. */
; 145  :     if (state->direct == 0) {

  0015b	44 39 67 40	 cmp	 DWORD PTR [rdi+64], r12d
  0015f	75 13		 jne	 SHORT $LN2@gz_look

; 146  :         strm->avail_in = 0;

  00161	44 89 a7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r12d

; 147  :         state->eof = 1;

  00168	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [rdi+80], 1

; 148  :         state->x.have = 0;

  0016f	44 89 27	 mov	 DWORD PTR [rdi], r12d

; 149  :         return 0;

  00172	eb 3d		 jmp	 SHORT $LN15@gz_look
$LN2@gz_look:

; 150  :     }
; 151  : 
; 152  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 153  :        the output buffer is larger than the input buffer, which also assures
; 154  :        space for gzungetc() */
; 155  :     state->x.next = state->out;

  00174	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00178	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 156  :     if (strm->avail_in) {

  0017c	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [rdi+128]
  00182	85 c0		 test	 eax, eax
  00184	74 1d		 je	 SHORT $LN1@gz_look

; 157  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00186	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  0018a	44 8b c0	 mov	 r8d, eax
  0018d	e8 00 00 00 00	 call	 memcpy

; 158  :         state->x.have = strm->avail_in;

  00192	44 8b 9f 80 00
	00 00		 mov	 r11d, DWORD PTR [rdi+128]
  00199	44 89 1f	 mov	 DWORD PTR [rdi], r11d

; 159  :         strm->avail_in = 0;

  0019c	44 89 a7 80 00
	00 00		 mov	 DWORD PTR [rdi+128], r12d
$LN1@gz_look:

; 160  :     }
; 161  :     state->how = COPY;

  001a3	c7 47 44 01 00
	00 00		 mov	 DWORD PTR [rdi+68], 1

; 162  :     state->direct = 1;

  001aa	c7 47 40 01 00
	00 00		 mov	 DWORD PTR [rdi+64], 1
$LN15@gz_look:

; 163  :     return 0;

  001b1	33 c0		 xor	 eax, eax
$LN13@gz_look:

; 164  : }

  001b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  001b8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001bd	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c6	41 5c		 pop	 r12
  001c8	c3		 ret	 0
gz_look	ENDP
PUBLIC	gzdirect
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzdirect
_TEXT	SEGMENT
file$ = 48
gzdirect PROC						; COMDAT

; 544  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 545  :     gz_statep state;
; 546  : 
; 547  :     /* get internal structure */
; 548  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN2@gzdirect

; 549  :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 559  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN2@gzdirect:

; 550  :     state = (gz_statep)file;
; 551  : 
; 552  :     /* if the state is not known, but we can find out, then do so (this is
; 553  :        mainly for right after a gzopen() or gzdopen()) */
; 554  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00016	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001d	75 10		 jne	 SHORT $LN1@gzdirect
  0001f	83 79 44 00	 cmp	 DWORD PTR [rcx+68], 0
  00023	75 0a		 jne	 SHORT $LN1@gzdirect
  00025	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00028	75 05		 jne	 SHORT $LN1@gzdirect

; 555  :         (void)gz_look(state);

  0002a	e8 00 00 00 00	 call	 gz_look
$LN1@gzdirect:

; 556  : 
; 557  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 558  :     return state->direct;

  0002f	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]

; 559  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_fetch DD imagerel gz_fetch
	DD	imagerel gz_fetch+165
	DD	imagerel $unwind$gz_fetch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_fetch DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_fetch
_TEXT	SEGMENT
state$ = 48
gz_fetch PROC						; COMDAT

; 227  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@gz_fetch:

; 228  :     z_streamp strm = &(state->strm);
; 229  : 
; 230  :     do {
; 231  :         switch(state->how) {

  00010	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00013	85 c9		 test	 ecx, ecx
  00015	74 34		 je	 SHORT $LN8@gz_fetch
  00017	ff c9		 dec	 ecx
  00019	74 5f		 je	 SHORT $LN5@gz_fetch
  0001b	ff c9		 dec	 ecx
  0001d	75 3f		 jne	 SHORT $LN12@gz_fetch

; 244  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 245  :             strm->avail_out = state->size << 1;

  0001f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 246  :             strm->next_out = state->out;
; 247  :             if (gz_decomp(state) == -1)

  00022	48 8b cb	 mov	 rcx, rbx
  00025	03 c0		 add	 eax, eax
  00027	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax
  0002d	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00031	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
  00038	e8 00 00 00 00	 call	 gz_decomp
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	75 1c		 jne	 SHORT $LN12@gz_fetch
$LN19@gz_fetch:

; 234  :                 return -1;

  00042	83 c8 ff	 or	 eax, -1

; 251  :     return 0;
; 252  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN8@gz_fetch:

; 232  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 233  :             if (gz_look(state) == -1)

  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 gz_look
  00053	83 f8 ff	 cmp	 eax, -1
  00056	74 ea		 je	 SHORT $LN19@gz_fetch

; 235  :             if (state->how == LOOK)

  00058	83 7b 44 00	 cmp	 DWORD PTR [rbx+68], 0
  0005c	74 3f		 je	 SHORT $LN20@gz_fetch
$LN12@gz_fetch:

; 248  :                 return -1;
; 249  :         }
; 250  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  0005e	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00061	75 3a		 jne	 SHORT $LN20@gz_fetch
  00063	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  00067	74 a7		 je	 SHORT $LL13@gz_fetch
  00069	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00070	75 9e		 jne	 SHORT $LL13@gz_fetch

; 243  :             return 0;

  00072	33 c0		 xor	 eax, eax

; 251  :     return 0;
; 252  : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
$LN5@gz_fetch:

; 236  :                 return 0;
; 237  :             break;
; 238  :         case COPY:      /* -> COPY */
; 239  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 240  :                     == -1)

  0007a	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0007e	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00082	4c 8b cb	 mov	 r9, rbx
  00085	45 03 c0	 add	 r8d, r8d
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 gz_load
  00090	83 f8 ff	 cmp	 eax, -1

; 241  :                 return -1;

  00093	74 ad		 je	 SHORT $LN19@gz_fetch

; 242  :             state->x.next = state->out;

  00095	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00099	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN20@gz_fetch:

; 243  :             return 0;

  0009d	33 c0		 xor	 eax, eax

; 251  :     return 0;
; 252  : }

  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5b		 pop	 rbx
  000a4	c3		 ret	 0
gz_fetch ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+118
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_skip
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_skip	PROC						; COMDAT

; 258  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 259  :     unsigned n;
; 260  : 
; 261  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 262  :     while (len)

  00010	48 85 d2	 test	 rdx, rdx
  00013	74 46		 je	 SHORT $LN6@gz_skip
$LL7@gz_skip:

; 263  :         /* skip over whatever is in output buffer */
; 264  :         if (state->x.have) {

  00015	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00017	85 c9		 test	 ecx, ecx
  00019	74 1f		 je	 SHORT $LN5@gz_skip

; 265  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
; 266  :                 (unsigned)len : state->x.have;

  0001b	48 3b cf	 cmp	 rcx, rdi
  0001e	44 8b c7	 mov	 r8d, edi
  00021	44 0f 4e c1	 cmovle	 r8d, ecx

; 267  :             state->x.have -= n;
; 268  :             state->x.next += n;

  00025	41 8b c0	 mov	 eax, r8d
  00028	41 2b c8	 sub	 ecx, r8d
  0002b	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 269  :             state->x.pos += n;

  0002f	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 270  :             len -= n;

  00033	48 2b f8	 sub	 rdi, rax
  00036	89 0b		 mov	 DWORD PTR [rbx], ecx
  00038	eb 1c		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 271  :         }
; 272  : 
; 273  :         /* output buffer empty -- return if we're at the end of the input */
; 274  :         else if (state->eof && state->strm.avail_in == 0)

  0003a	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0003e	74 09		 je	 SHORT $LN3@gz_skip
  00040	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00047	74 12		 je	 SHORT $LN6@gz_skip
$LN3@gz_skip:

; 275  :             break;
; 276  : 
; 277  :         /* need more data to skip -- load up output buffer */
; 278  :         else {
; 279  :             /* get more output, looking for header if required */
; 280  :             if (gz_fetch(state) == -1)

  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 gz_fetch
  00051	83 f8 ff	 cmp	 eax, -1
  00054	74 12		 je	 SHORT $LN14@gz_skip
$LN1@gz_skip:

; 259  :     unsigned n;
; 260  : 
; 261  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 262  :     while (len)

  00056	48 85 ff	 test	 rdi, rdi
  00059	75 ba		 jne	 SHORT $LL7@gz_skip
$LN6@gz_skip:

; 282  :         }
; 283  :     return 0;

  0005b	33 c0		 xor	 eax, eax

; 284  : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN14@gz_skip:

; 281  :                 return -1;

  00068	83 c8 ff	 or	 eax, -1

; 284  : }

  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
gz_skip	ENDP
PUBLIC	gzgets
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN29
	DD	imagerel $LN29+110
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzgets DD imagerel $LN29+110
	DD	imagerel $LN29+305
	DD	imagerel $chain$3$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzgets DD imagerel $LN29+305
	DD	imagerel $LN29+309
	DD	imagerel $chain$5$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gzgets DD imagerel $LN29+309
	DD	imagerel $LN29+321
	DD	imagerel $chain$6$gzgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gzgets DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+110
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzgets DD 080021H
	DD	0be400H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN29
	DD	imagerel $LN29+110
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzgets DD 081421H
	DD	0be414H
	DD	0a740fH
	DD	09540aH
	DD	083405H
	DD	imagerel $LN29
	DD	imagerel $LN29+110
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 040a01H
	DD	0d006320aH
	DD	06002c004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzgets
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzgets	PROC						; COMDAT

; 482  : {

$LN29:
  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	45 8b e8	 mov	 r13d, r8d
  0000d	4c 8b e2	 mov	 r12, rdx
  00010	48 8b f1	 mov	 rsi, rcx

; 483  :     unsigned left, n;
; 484  :     char *str;
; 485  :     unsigned char *eol;
; 486  :     gz_statep state;
; 487  : 
; 488  :     /* check parameters and get internal structure */
; 489  :     if (file == NULL || buf == NULL || len < 1)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 19 01 00
	00		 je	 $LN12@gzgets
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 10 01 00
	00		 je	 $LN12@gzgets
  00025	41 83 f8 01	 cmp	 r8d, 1
  00029	0f 8c 06 01 00
	00		 jl	 $LN12@gzgets

; 490  :         return NULL;
; 491  :     state = (gz_statep)file;
; 492  : 
; 493  :     /* check that we're reading and that there's no (serious) error */
; 494  :     if (state->mode != GZ_READ ||
; 495  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0002f	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00036	0f 85 f9 00 00
	00		 jne	 $LN12@gzgets
  0003c	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN13@gzgets
  00043	83 f8 fb	 cmp	 eax, -5
  00046	0f 85 e9 00 00
	00		 jne	 $LN12@gzgets
$LN13@gzgets:

; 497  : 
; 498  :     /* process a skip request */
; 499  :     if (state->seek) {

  0004c	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00050	74 19		 je	 SHORT $LN10@gzgets

; 500  :         state->seek = 0;
; 501  :         if (gz_skip(state, state->skip) == -1)

  00052	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00056	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005d	e8 00 00 00 00	 call	 gz_skip
  00062	83 f8 ff	 cmp	 eax, -1

; 502  :             return NULL;

  00065	0f 84 ca 00 00
	00		 je	 $LN12@gzgets
$LN10@gzgets:

; 503  :     }
; 504  : 
; 505  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 506  :        append a terminating zero to the string (we don't check for a zero in
; 507  :        the contents, let the user worry about that) */
; 508  :     str = buf;
; 509  :     left = (unsigned)len - 1;

  0006b	41 ff cd	 dec	 r13d
  0006e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00073	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00078	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0007d	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00082	4d 8b f4	 mov	 r14, r12

; 510  :     if (left) do {

  00085	0f 84 a6 00 00
	00		 je	 $LN23@gzgets
  0008b	0f 1f 44 00 00	 npad	 5
$LL8@gzgets:

; 511  :         /* assure that something is in the output buffer */
; 512  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00090	8b 3e		 mov	 edi, DWORD PTR [rsi]
  00092	85 ff		 test	 edi, edi
  00094	75 17		 jne	 SHORT $LN24@gzgets
  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 gz_fetch
  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	0f 84 8a 00 00
	00		 je	 $LN23@gzgets

; 513  :             return NULL;                /* error */
; 514  :         if (state->x.have == 0) {       /* end of file */

  000a7	8b 3e		 mov	 edi, DWORD PTR [rsi]
  000a9	85 ff		 test	 edi, edi
  000ab	74 52		 je	 SHORT $LN22@gzgets
$LN24@gzgets:

; 516  :             break;                      /* return what we have */
; 517  :         }
; 518  : 
; 519  :         /* look for end-of-line in current output buffer */
; 520  :         n = state->x.have > left ? left : state->x.have;
; 521  :         eol = memchr(state->x.next, '\n', n);

  000ad	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000b1	41 3b fd	 cmp	 edi, r13d
  000b4	ba 0a 00 00 00	 mov	 edx, 10
  000b9	41 0f 47 fd	 cmova	 edi, r13d
  000bd	44 8b c7	 mov	 r8d, edi
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c6	48 8b e8	 mov	 rbp, rax

; 522  :         if (eol != NULL)

  000c9	48 85 c0	 test	 rax, rax
  000cc	74 07		 je	 SHORT $LN3@gzgets

; 523  :             n = (unsigned)(eol - state->x.next) + 1;

  000ce	8b f8		 mov	 edi, eax
  000d0	2b 7e 08	 sub	 edi, DWORD PTR [rsi+8]
  000d3	ff c7		 inc	 edi
$LN3@gzgets:

; 524  : 
; 525  :         /* copy through end-of-line, or remainder if not found */
; 526  :         memcpy(buf, state->x.next, n);

  000d5	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  000d9	44 8b c7	 mov	 r8d, edi
  000dc	49 8b cc	 mov	 rcx, r12
  000df	8b df		 mov	 ebx, edi
  000e1	e8 00 00 00 00	 call	 memcpy

; 527  :         state->x.have -= n;

  000e6	29 3e		 sub	 DWORD PTR [rsi], edi

; 528  :         state->x.next += n;

  000e8	48 01 5e 08	 add	 QWORD PTR [rsi+8], rbx

; 529  :         state->x.pos += n;

  000ec	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 530  :         left -= n;
; 531  :         buf += n;

  000f0	4c 03 e3	 add	 r12, rbx
  000f3	44 2b ef	 sub	 r13d, edi

; 532  :     } while (left && eol == NULL);

  000f6	74 0e		 je	 SHORT $LN2@gzgets
  000f8	48 85 ed	 test	 rbp, rbp
  000fb	74 93		 je	 SHORT $LL8@gzgets
  000fd	eb 07		 jmp	 SHORT $LN2@gzgets
$LN22@gzgets:

; 515  :             state->past = 1;            /* read past end */

  000ff	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [rsi+84], 1
$LN2@gzgets:

; 533  : 
; 534  :     /* return terminated string, or if nothing, end of file */
; 535  :     if (buf == str)

  00106	4d 3b e6	 cmp	 r12, r14
  00109	74 26		 je	 SHORT $LN23@gzgets

; 537  :     buf[0] = 0;

  0010b	41 c6 04 24 00	 mov	 BYTE PTR [r12], 0

; 538  :     return str;

  00110	49 8b c6	 mov	 rax, r14
$LN28@gzgets:
  00113	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00118	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0011d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00122	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 539  : }

  00127	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012b	41 5d		 pop	 r13
  0012d	41 5c		 pop	 r12
  0012f	5e		 pop	 rsi
  00130	c3		 ret	 0
$LN23@gzgets:

; 536  :         return NULL;

  00131	33 c0		 xor	 eax, eax
  00133	eb de		 jmp	 SHORT $LN28@gzgets
$LN12@gzgets:

; 496  :         return NULL;

  00135	33 c0		 xor	 eax, eax

; 539  : }

  00137	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013b	41 5d		 pop	 r13
  0013d	41 5c		 pop	 r12
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
PUBLIC	gzungetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN16
	DD	imagerel $LN16+267
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzungetc
_TEXT	SEGMENT
c$ = 48
file$ = 56
gzungetc PROC						; COMDAT

; 421  : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 422  :     gz_statep state;
; 423  : 
; 424  :     /* get internal structure */
; 425  :     if (file == NULL)

  0000f	48 85 d2	 test	 rdx, rdx

; 426  :         return -1;

  00012	0f 84 8f 00 00
	00		 je	 $LN9@gzungetc

; 427  :     state = (gz_statep)file;
; 428  : 
; 429  :     /* check that we're reading and that there's no (serious) error */
; 430  :     if (state->mode != GZ_READ ||
; 431  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00018	81 7a 18 4f 1c
	00 00		 cmp	 DWORD PTR [rdx+24], 7247 ; 00001c4fH
  0001f	0f 85 82 00 00
	00		 jne	 $LN9@gzungetc
  00025	8b 42 6c	 mov	 eax, DWORD PTR [rdx+108]
  00028	85 c0		 test	 eax, eax
  0002a	74 05		 je	 SHORT $LN10@gzungetc
  0002c	83 f8 fb	 cmp	 eax, -5
  0002f	75 76		 jne	 SHORT $LN9@gzungetc
$LN10@gzungetc:

; 433  : 
; 434  :     /* process a skip request */
; 435  :     if (state->seek) {

  00031	83 7a 68 00	 cmp	 DWORD PTR [rdx+104], 0
  00035	74 18		 je	 SHORT $LN7@gzungetc

; 436  :         state->seek = 0;

  00037	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [rdx+104], 0

; 437  :         if (gz_skip(state, state->skip) == -1)

  0003e	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 gz_skip
  0004a	83 f8 ff	 cmp	 eax, -1

; 438  :             return -1;

  0004d	74 58		 je	 SHORT $LN9@gzungetc
$LN7@gzungetc:

; 439  :     }
; 440  : 
; 441  :     /* can't push EOF */
; 442  :     if (c < 0)

  0004f	85 ff		 test	 edi, edi

; 443  :         return -1;

  00051	78 54		 js	 SHORT $LN9@gzungetc

; 444  : 
; 445  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 446  :     if (state->x.have == 0) {

  00053	8b 0b		 mov	 ecx, DWORD PTR [rbx]

; 447  :         state->x.have = 1;
; 448  :         state->x.next = state->out + (state->size << 1) - 1;

  00055	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 31		 jne	 SHORT $LN5@gzungetc
  0005c	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  0005f	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00063	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  00069	48 8d 54 01 ff	 lea	 rdx, QWORD PTR [rcx+rax-1]

; 449  :         state->x.next[0] = c;
; 450  :         state->x.pos--;
; 451  :         state->past = 0;
; 452  :         return c;

  0006e	8b c7		 mov	 eax, edi
  00070	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  00074	40 88 3a	 mov	 BYTE PTR [rdx], dil
  00077	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  0007b	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 474  :     return c;
; 475  : }

  00082	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN5@gzungetc:

; 453  :     }
; 454  : 
; 455  :     /* if no room, give up (must have already done a gzungetc()) */
; 456  :     if (state->x.have == (state->size << 1)) {

  0008d	03 c0		 add	 eax, eax
  0008f	3b c8		 cmp	 ecx, eax
  00091	75 22		 jne	 SHORT $LN4@gzungetc

; 457  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00093	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  0009a	ba fd ff ff ff	 mov	 edx, -3
  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	e8 00 00 00 00	 call	 gz_error
$LN9@gzungetc:

; 432  :         return -1;

  000a7	83 c8 ff	 or	 eax, -1

; 474  :     return c;
; 475  : }

  000aa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
$LN4@gzungetc:

; 458  :         return -1;
; 459  :     }
; 460  : 
; 461  :     /* slide output data if needed and insert byte before existing data */
; 462  :     if (state->x.next == state->out) {

  000b5	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  000b9	4c 39 43 08	 cmp	 QWORD PTR [rbx+8], r8
  000bd	75 27		 jne	 SHORT $LN3@gzungetc

; 463  :         unsigned char *src = state->out + state->x.have;
; 464  :         unsigned char *dest = state->out + (state->size << 1);

  000bf	8b d0		 mov	 edx, eax
  000c1	49 03 c8	 add	 rcx, r8
  000c4	49 03 d0	 add	 rdx, r8

; 465  :         while (src > state->out)

  000c7	49 3b c8	 cmp	 rcx, r8
  000ca	76 16		 jbe	 SHORT $LN1@gzungetc
  000cc	0f 1f 40 00	 npad	 4
$LL2@gzungetc:

; 466  :             *--dest = *--src;

  000d0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  000d4	48 ff c9	 dec	 rcx
  000d7	48 ff ca	 dec	 rdx
  000da	88 02		 mov	 BYTE PTR [rdx], al
  000dc	48 3b 4b 38	 cmp	 rcx, QWORD PTR [rbx+56]
  000e0	77 ee		 ja	 SHORT $LL2@gzungetc
$LN1@gzungetc:

; 467  :         state->x.next = dest;

  000e2	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
$LN3@gzungetc:

; 468  :     }
; 469  :     state->x.have++;
; 470  :     state->x.next--;

  000e6	48 ff 4b 08	 dec	 QWORD PTR [rbx+8]
  000ea	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ee	ff 03		 inc	 DWORD PTR [rbx]

; 471  :     state->x.next[0] = c;

  000f0	40 88 38	 mov	 BYTE PTR [rax], dil

; 472  :     state->x.pos--;

  000f3	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]

; 473  :     state->past = 0;

  000f7	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 474  :     return c;
; 475  : }

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	8b c7		 mov	 eax, edi
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
PUBLIC	gzread
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzread DD imagerel $LN38+91
	DD	imagerel $LN38+139
	DD	imagerel $chain$0$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzread DD imagerel $LN38+139
	DD	imagerel $LN38+419
	DD	imagerel $chain$5$gzread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzread DD 081221H
	DD	0b3412H
	DD	05d40aH
	DD	0c6405H
	DD	04e400H
	DD	imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzread DD 020521H
	DD	04e405H
	DD	imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 040901H
	DD	0c0055209H
	DD	050027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzread
_TEXT	SEGMENT
n$ = 80
file$ = 80
buf$ = 88
len$ = 96
gzread	PROC						; COMDAT

; 291  : {

$LN38:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	41 8b e8	 mov	 ebp, r8d
  0000c	4c 8b e2	 mov	 r12, rdx
  0000f	48 8b f9	 mov	 rdi, rcx

; 292  :     unsigned got, n;
; 293  :     gz_statep state;
; 294  :     z_streamp strm;
; 295  : 
; 296  :     /* get internal structure */
; 297  :     if (file == NULL)

  00012	48 85 c9	 test	 rcx, rcx

; 298  :         return -1;

  00015	74 2b		 je	 SHORT $LN37@gzread

; 299  :     state = (gz_statep)file;
; 300  :     strm = &(state->strm);
; 301  : 
; 302  :     /* check that we're reading and that there's no (serious) error */
; 303  :     if (state->mode != GZ_READ ||
; 304  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001e	75 22		 jne	 SHORT $LN37@gzread
  00020	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00023	85 c0		 test	 eax, eax
  00025	74 05		 je	 SHORT $LN21@gzread
  00027	83 f8 fb	 cmp	 eax, -5
  0002a	75 16		 jne	 SHORT $LN37@gzread
$LN21@gzread:

; 305  :         return -1;
; 306  : 
; 307  :     /* since an int is returned, make sure len fits in one, otherwise return
; 308  :        with an error (this avoids the flaw in the interface) */
; 309  :     if ((int)len < 0) {

  0002c	45 85 c0	 test	 r8d, r8d
  0002f	79 1d		 jns	 SHORT $LN36@gzread

; 310  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00031	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00038	ba fd ff ff ff	 mov	 edx, -3
  0003d	e8 00 00 00 00	 call	 gz_error
$LN37@gzread:

; 311  :         return -1;

  00042	83 c8 ff	 or	 eax, -1

; 378  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	41 5c		 pop	 r12
  0004b	5f		 pop	 rdi
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
$LN36@gzread:

; 312  :     }
; 313  : 
; 314  :     /* if len is zero, avoid unnecessary operations */
; 315  :     if (len == 0)

  0004e	75 0b		 jne	 SHORT $LN18@gzread

; 316  :         return 0;

  00050	33 c0		 xor	 eax, eax

; 378  : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	41 5c		 pop	 r12
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
$LN18@gzread:
  0005b	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 317  : 
; 318  :     /* process a skip request */
; 319  :     if (state->seek) {

  00060	45 33 f6	 xor	 r14d, r14d
  00063	44 39 71 68	 cmp	 DWORD PTR [rcx+104], r14d
  00067	74 22		 je	 SHORT $LN16@gzread

; 320  :         state->seek = 0;
; 321  :         if (gz_skip(state, state->skip) == -1)

  00069	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0006d	44 89 71 68	 mov	 DWORD PTR [rcx+104], r14d
  00071	e8 00 00 00 00	 call	 gz_skip
  00076	83 f8 ff	 cmp	 eax, -1
  00079	75 10		 jne	 SHORT $LN16@gzread

; 322  :             return -1;

  0007b	0b c0		 or	 eax, eax
  0007d	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 378  : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	41 5c		 pop	 r12
  00088	5f		 pop	 rdi
  00089	5d		 pop	 rbp
  0008a	c3		 ret	 0
$LN16@gzread:
  0008b	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00090	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13

; 323  :     }
; 324  : 
; 325  :     /* get len bytes to buf, or less than len if at the end */
; 326  :     got = 0;

  00095	45 8b ee	 mov	 r13d, r14d
  00098	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0009d	0f 1f 00	 npad	 3
$LL15@gzread:

; 327  :     do {
; 328  :         /* first just try copying data from the output buffer */
; 329  :         if (state->x.have) {

  000a0	8b 37		 mov	 esi, DWORD PTR [rdi]
  000a2	85 f6		 test	 esi, esi
  000a4	74 33		 je	 SHORT $LN12@gzread

; 330  :             n = state->x.have > len ? len : state->x.have;
; 331  :             memcpy(buf, state->x.next, n);

  000a6	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000aa	3b f5		 cmp	 esi, ebp
  000ac	49 8b cc	 mov	 rcx, r12
  000af	0f 47 f5	 cmova	 esi, ebp
  000b2	44 8b c6	 mov	 r8d, esi
  000b5	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  000b9	8b de		 mov	 ebx, esi
  000bb	e8 00 00 00 00	 call	 memcpy

; 332  :             state->x.next += n;

  000c0	48 01 5f 08	 add	 QWORD PTR [rdi+8], rbx

; 333  :             state->x.have -= n;

  000c4	29 37		 sub	 DWORD PTR [rdi], esi

; 367  :         }
; 368  : 
; 369  :         /* update progress */
; 370  :         len -= n;
; 371  :         buf = (char *)buf + n;

  000c6	8b c6		 mov	 eax, esi
  000c8	2b ee		 sub	 ebp, esi

; 372  :         got += n;

  000ca	44 03 ee	 add	 r13d, esi
  000cd	4c 03 e0	 add	 r12, rax

; 373  :         state->x.pos += n;

  000d0	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  000d4	e9 91 00 00 00	 jmp	 $LN14@gzread
$LN12@gzread:

; 334  :         }
; 335  : 
; 336  :         /* output buffer empty -- return if we're at the end of the input */
; 337  :         else if (state->eof && strm->avail_in == 0) {

  000d9	44 39 77 50	 cmp	 DWORD PTR [rdi+80], r14d
  000dd	74 0d		 je	 SHORT $LN10@gzread
  000df	44 39 b7 80 00
	00 00		 cmp	 DWORD PTR [rdi+128], r14d
  000e6	0f 84 8b 00 00
	00		 je	 $LN28@gzread
$LN10@gzread:

; 339  :             break;
; 340  :         }
; 341  : 
; 342  :         /* need output data -- for small len or new stream load up our output
; 343  :            buffer */
; 344  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000ec	8b 4f 44	 mov	 ecx, DWORD PTR [rdi+68]
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 6a		 je	 SHORT $LN7@gzread
  000f3	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  000f6	03 c0		 add	 eax, eax
  000f8	3b e8		 cmp	 ebp, eax
  000fa	72 61		 jb	 SHORT $LN7@gzread

; 348  :             continue;       /* no progress yet -- go back to copy above */
; 349  :             /* the copy above assures that we will leave with space in the
; 350  :                output buffer, allowing at least one gzungetc() to succeed */
; 351  :         }
; 352  : 
; 353  :         /* large len -- read directly into user buffer */
; 354  :         else if (state->how == COPY) {      /* read directly */

  000fc	83 f9 01	 cmp	 ecx, 1

; 355  :             if (gz_load(state, buf, len, &n) == -1)

  000ff	48 8b cf	 mov	 rcx, rdi
  00102	75 29		 jne	 SHORT $LN4@gzread
  00104	4c 8d 4c 24 50	 lea	 r9, QWORD PTR n$[rsp]
  00109	44 8b c5	 mov	 r8d, ebp
  0010c	49 8b d4	 mov	 rdx, r12
  0010f	e8 00 00 00 00	 call	 gz_load
  00114	83 f8 ff	 cmp	 eax, -1
  00117	74 6a		 je	 SHORT $LN31@gzread

; 356  :                 return -1;
; 357  :         }
; 358  : 
; 359  :         /* large len -- decompress directly into user buffer */
; 360  :         else {  /* state->how == GZIP */

  00119	8b 74 24 50	 mov	 esi, DWORD PTR n$[rsp]

; 367  :         }
; 368  : 
; 369  :         /* update progress */
; 370  :         len -= n;
; 371  :         buf = (char *)buf + n;

  0011d	8b c6		 mov	 eax, esi
  0011f	2b ee		 sub	 ebp, esi

; 372  :         got += n;

  00121	44 03 ee	 add	 r13d, esi
  00124	4c 03 e0	 add	 r12, rax

; 373  :         state->x.pos += n;

  00127	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  0012b	eb 3d		 jmp	 SHORT $LN14@gzread
$LN4@gzread:

; 361  :             strm->avail_out = len;

  0012d	89 af 90 00 00
	00		 mov	 DWORD PTR [rdi+144], ebp

; 362  :             strm->next_out = buf;

  00133	4c 89 a7 88 00
	00 00		 mov	 QWORD PTR [rdi+136], r12

; 363  :             if (gz_decomp(state) == -1)

  0013a	e8 00 00 00 00	 call	 gz_decomp
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 3f		 je	 SHORT $LN31@gzread

; 364  :                 return -1;
; 365  :             n = state->x.have;

  00144	8b 37		 mov	 esi, DWORD PTR [rdi]

; 366  :             state->x.have = 0;

  00146	44 89 37	 mov	 DWORD PTR [rdi], r14d

; 367  :         }
; 368  : 
; 369  :         /* update progress */
; 370  :         len -= n;
; 371  :         buf = (char *)buf + n;

  00149	8b c6		 mov	 eax, esi
  0014b	2b ee		 sub	 ebp, esi

; 372  :         got += n;

  0014d	44 03 ee	 add	 r13d, esi
  00150	4c 03 e0	 add	 r12, rax

; 373  :         state->x.pos += n;

  00153	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00157	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  0015b	eb 0d		 jmp	 SHORT $LN14@gzread
$LN7@gzread:

; 345  :             /* get more output, looking for header if required */
; 346  :             if (gz_fetch(state) == -1)

  0015d	48 8b cf	 mov	 rcx, rdi
  00160	e8 00 00 00 00	 call	 gz_fetch
  00165	83 f8 ff	 cmp	 eax, -1
  00168	74 19		 je	 SHORT $LN31@gzread
$LN14@gzread:

; 374  :     } while (len);

  0016a	85 ed		 test	 ebp, ebp
  0016c	0f 85 2e ff ff
	ff		 jne	 $LL15@gzread

; 375  : 
; 376  :     /* return number of bytes read into user buffer (will fit in int) */
; 377  :     return (int)got;

  00172	41 8b c5	 mov	 eax, r13d
  00175	eb 0f		 jmp	 SHORT $LN35@gzread
$LN28@gzread:

; 338  :             state->past = 1;        /* tried to read past end */

  00177	c7 47 54 01 00
	00 00		 mov	 DWORD PTR [rdi+84], 1

; 375  : 
; 376  :     /* return number of bytes read into user buffer (will fit in int) */
; 377  :     return (int)got;

  0017e	41 8b c5	 mov	 eax, r13d
  00181	eb 03		 jmp	 SHORT $LN35@gzread
$LN31@gzread:

; 347  :                 return -1;

  00183	83 c8 ff	 or	 eax, -1
$LN35@gzread:
  00186	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0018b	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00190	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  00195	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 378  : }

  0019a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019e	41 5c		 pop	 r12
  001a0	5f		 pop	 rdi
  001a1	5d		 pop	 rbp
  001a2	c3		 ret	 0
gzread	ENDP
PUBLIC	gzgetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN9
	DD	imagerel $LN9+107
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzgetc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
gzgetc	PROC						; COMDAT

; 384  : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 385  :     int ret;
; 386  :     unsigned char buf[1];
; 387  :     gz_statep state;
; 388  : 
; 389  :     /* get internal structure */
; 390  :     if (file == NULL)

  00007	48 85 c9	 test	 rcx, rcx

; 391  :         return -1;

  0000a	74 57		 je	 SHORT $LN2@gzgetc

; 392  :     state = (gz_statep)file;
; 393  : 
; 394  :     /* check that we're reading and that there's no (serious) error */
; 395  :     if (state->mode != GZ_READ ||
; 396  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000c	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00013	75 4e		 jne	 SHORT $LN2@gzgetc
  00015	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN3@gzgetc
  0001c	83 f8 fb	 cmp	 eax, -5
  0001f	75 42		 jne	 SHORT $LN2@gzgetc
$LN3@gzgetc:

; 398  : 
; 399  :     /* try output buffer (no need to check for skip request) */
; 400  :     if (state->x.have) {

  00021	8b 01		 mov	 eax, DWORD PTR [rcx]
  00023	85 c0		 test	 eax, eax
  00025	74 1d		 je	 SHORT $LN1@gzgetc

; 401  :         state->x.have--;
; 402  :         state->x.pos++;

  00027	48 ff 41 10	 inc	 QWORD PTR [rcx+16]
  0002b	ff c8		 dec	 eax
  0002d	89 01		 mov	 DWORD PTR [rcx], eax

; 403  :         return *(state->x.next)++;

  0002f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00033	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00036	48 ff c0	 inc	 rax
  00039	49 89 41 08	 mov	 QWORD PTR [r9+8], rax
  0003d	8b c1		 mov	 eax, ecx

; 409  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN1@gzgetc:

; 404  :     }
; 405  : 
; 406  :     /* nothing there -- try gzread() */
; 407  :     ret = gzread(file, buf, 1);

  00044	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00049	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004f	e8 00 00 00 00	 call	 gzread

; 408  :     return ret < 1 ? -1 : buf[0];

  00054	83 f8 01	 cmp	 eax, 1
  00057	7c 0a		 jl	 SHORT $LN2@gzgetc
  00059	0f b6 44 24 30	 movzx	 eax, BYTE PTR buf$[rsp]

; 409  : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
$LN2@gzgetc:

; 397  :         return -1;

  00063	83 c8 ff	 or	 eax, -1

; 409  : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
PUBLIC	gzgetc_
; Function compile flags: /Ogtpy
;	COMDAT gzgetc_
_TEXT	SEGMENT
file$ = 8
gzgetc_	PROC						; COMDAT

; 414  :     return gzgetc(file);
; 415  : }

  00000	e9 00 00 00 00	 jmp	 gzgetc
gzgetc_	ENDP
_TEXT	ENDS
END
