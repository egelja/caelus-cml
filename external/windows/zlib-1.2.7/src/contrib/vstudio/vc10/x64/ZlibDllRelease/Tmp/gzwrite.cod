; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	__imp_vsnprintf:PROC
EXTRN	__imp_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
;	COMDAT pdata
; File c:\users\darrin\downloads\zlib127\zlib-1.2.7\gzwrite.c
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+269
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_init
_TEXT	SEGMENT
state$ = 80
gz_init	PROC						; COMDAT

; 17   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = malloc(state->want);

  00014	8b 69 2c	 mov	 ebp, DWORD PTR [rcx+44]
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	8b cd		 mov	 ecx, ebp
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00022	48 8b f0	 mov	 rsi, rax
  00025	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 23   :     if (state->in == NULL) {

  00029	48 85 c0	 test	 rax, rax

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");
; 25   :         return -1;

  0002c	74 24		 je	 SHORT $LN8@gz_init

; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  0002e	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00032	0f 85 9d 00 00
	00		 jne	 $LN2@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = malloc(state->want);

  00038	8b cd		 mov	 ecx, ebp
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00040	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 32   :         if (state->out == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	75 25		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00049	48 8b ce	 mov	 rcx, rsi
$LN9@gz_init:
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gz_init:

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00059	ba fc ff ff ff	 mov	 edx, -4
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 gz_error

; 35   :             return -1;

  00066	83 c8 ff	 or	 eax, -1
  00069	e9 8a 00 00 00	 jmp	 $LN6@gz_init
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;

  0006e	33 c0		 xor	 eax, eax

; 40   :         strm->zfree = Z_NULL;
; 41   :         strm->opaque = Z_NULL;
; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  00070	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  00078	41 b9 1f 00 00
	00		 mov	 r9d, 31
  0007e	48 89 83 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rax
  00085	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax
  0008c	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
  00093	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05HBMOAMF@1?42?47?$AA@
  0009d	45 8d 41 e9	 lea	 r8d, QWORD PTR [r9-23]
  000a1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000a6	8b 43 5c	 mov	 eax, DWORD PTR [rbx+92]
  000a9	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  000ad	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b1	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000b9	e8 00 00 00 00	 call	 deflateInit2_

; 44   :         if (ret != Z_OK) {

  000be	85 c0		 test	 eax, eax
  000c0	74 13		 je	 SHORT $LN2@gz_init

; 45   :             free(state->out);

  000c2	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 46   :             free(state->in);

  000cc	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");
; 48   :             return -1;

  000d0	e9 77 ff ff ff	 jmp	 $LN9@gz_init
$LN2@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;
; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  000d5	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  000d9	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000dc	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  000df	75 15		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  000e1	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax

; 58   :         strm->next_out = state->out;

  000e7	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000eb	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 59   :         state->x.next = strm->next_out;

  000f2	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  000f6	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 62   : }

  000f8	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fd	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00102	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00107	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
gz_init	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+372
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 089801H
	DD	066498H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_comp
_TEXT	SEGMENT
state$ = 48
flush$ = 56
gz_comp	PROC						; COMDAT

; 73   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);
; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00013	8b ea		 mov	 ebp, edx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	75 0a		 jne	 SHORT $LN15@gz_comp
  0001a	e8 00 00 00 00	 call	 gz_init
  0001f	83 f8 ff	 cmp	 eax, -1

; 80   :         return -1;

  00022	74 5a		 je	 SHORT $LN23@gz_comp
$LN15@gz_comp:

; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  00024	83 7f 40 00	 cmp	 DWORD PTR [rdi+64], 0
  00028	74 67		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  0002a	44 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [rdi+128]
  00031	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  00035	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  0003e	85 c0		 test	 eax, eax
  00040	78 20		 js	 SHORT $LN12@gz_comp
  00042	3b 87 80 00 00
	00		 cmp	 eax, DWORD PTR [rdi+128]
  00048	75 18		 jne	 SHORT $LN12@gz_comp

; 88   :         }
; 89   :         strm->avail_in = 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	89 87 80 00 00
	00		 mov	 DWORD PTR [rdi+128], eax

; 130  : }

  00052	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00057	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00068	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00070	83 ca ff	 or	 edx, -1
  00073	48 8b cf	 mov	 rcx, rdi
  00076	4c 8b c0	 mov	 r8, rax
  00079	e8 00 00 00 00	 call	 gz_error
$LN23@gz_comp:

; 87   :             return -1;

  0007e	83 c8 ff	 or	 eax, -1

; 130  : }

  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN14@gz_comp:

; 90   :         return 0;
; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  00091	33 c0		 xor	 eax, eax
  00093	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  000a0	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  000a7	74 0e		 je	 SHORT $LN6@gz_comp
  000a9	85 ed		 test	 ebp, ebp
  000ab	74 55		 je	 SHORT $LN8@gz_comp
  000ad	83 fd 04	 cmp	 ebp, 4
  000b0	75 05		 jne	 SHORT $LN6@gz_comp
  000b2	83 f8 01	 cmp	 eax, 1
  000b5	75 4b		 jne	 SHORT $LN8@gz_comp
$LN6@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  000b7	8b b7 88 00 00
	00		 mov	 esi, DWORD PTR [rdi+136]
  000bd	2b 77 08	 sub	 esi, DWORD PTR [rdi+8]

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  000c0	74 18		 je	 SHORT $LN5@gz_comp
  000c2	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000c6	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  000c9	44 8b c6	 mov	 r8d, esi
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  000d2	85 c0		 test	 eax, eax
  000d4	78 5c		 js	 SHORT $LN4@gz_comp
  000d6	3b c6		 cmp	 eax, esi
  000d8	75 58		 jne	 SHORT $LN4@gz_comp
$LN5@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  000da	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  000e1	75 14		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  000e3	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  000e6	89 87 90 00 00
	00		 mov	 DWORD PTR [rdi+144], eax

; 108  :                 strm->next_out = state->out;

  000ec	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000f0	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  000f7	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  000fe	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  00102	8b b7 90 00 00
	00		 mov	 esi, DWORD PTR [rdi+144]

; 115  :         ret = deflate(strm, flush);

  00108	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  0010c	8b d5		 mov	 edx, ebp
  0010e	e8 00 00 00 00	 call	 deflate

; 116  :         if (ret == Z_STREAM_ERROR) {

  00113	83 f8 fe	 cmp	 eax, -2
  00116	74 30		 je	 SHORT $LN20@gz_comp

; 120  :         }
; 121  :         have -= strm->avail_out;

  00118	3b b7 90 00 00
	00		 cmp	 esi, DWORD PTR [rdi+144]

; 122  :     } while (have);

  0011e	75 80		 jne	 SHORT $LL11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  00120	83 fd 04	 cmp	 ebp, 4
  00123	75 09		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  00125	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00129	e8 00 00 00 00	 call	 deflateReset
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 2d		 jmp	 SHORT $LN21@gz_comp
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00138	8b 08		 mov	 ecx, DWORD PTR [rax]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00140	83 ca ff	 or	 edx, -1
  00143	4c 8b c0	 mov	 r8, rax

; 104  :                 return -1;

  00146	eb 0c		 jmp	 SHORT $LN22@gz_comp
$LN20@gz_comp:

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  00148	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  0014f	ba fe ff ff ff	 mov	 edx, -2
$LN22@gz_comp:
  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 gz_error

; 119  :             return -1;

  0015c	83 c8 ff	 or	 eax, -1
$LN21@gz_comp:

; 130  : }

  0015f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00164	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00169	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0016e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
gz_comp	ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_zero DD imagerel gz_zero+50
	DD	imagerel gz_zero+172
	DD	imagerel $chain$1$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_zero DD imagerel gz_zero+172
	DD	imagerel gz_zero+177
	DD	imagerel $chain$3$gz_zero
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_zero DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_zero DD 040a21H
	DD	07640aH
	DD	065405H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 040a01H
	DD	08340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gz_zero
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_zero	PROC						; COMDAT

; 136  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);
; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000a	83 b9 80 00 00
	00 00		 cmp	 DWORD PTR [rcx+128], 0
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	74 19		 je	 SHORT $LN5@gz_zero
  00019	33 d2		 xor	 edx, edx
  0001b	e8 00 00 00 00	 call	 gz_comp
  00020	83 f8 ff	 cmp	 eax, -1
  00023	75 0d		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  00025	0b c0		 or	 eax, eax

; 162  : }

  00027	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN5@gz_zero:
  00032	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00037	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;

  0003c	bd 01 00 00 00	 mov	 ebp, 1

; 147  :     while (len) {

  00041	48 85 db	 test	 rbx, rbx
  00044	74 4f		 je	 SHORT $LN3@gz_zero
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@gz_zero:

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00050	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  00053	8b f3		 mov	 esi, ebx
  00055	48 3b c3	 cmp	 rax, rbx
  00058	0f 4e f0	 cmovle	 esi, eax

; 150  :         if (first) {

  0005b	85 ed		 test	 ebp, ebp
  0005d	74 10		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  0005f	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00063	44 8b c6	 mov	 r8d, esi
  00066	33 d2		 xor	 edx, edx
  00068	e8 00 00 00 00	 call	 memset

; 152  :             first = 0;

  0006d	33 ed		 xor	 ebp, ebp
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  0006f	89 b7 80 00 00
	00		 mov	 DWORD PTR [rdi+128], esi

; 155  :         strm->next_in = state->in;

  00075	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]

; 156  :         state->x.pos += n;
; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00079	33 d2		 xor	 edx, edx
  0007b	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  0007f	48 01 77 10	 add	 QWORD PTR [rdi+16], rsi
  00083	48 8b cf	 mov	 rcx, rdi
  00086	e8 00 00 00 00	 call	 gz_comp
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	74 1c		 je	 SHORT $LN11@gz_zero

; 159  :         len -= n;

  00090	48 2b de	 sub	 rbx, rsi

; 147  :     while (len) {

  00093	75 bb		 jne	 SHORT $LL4@gz_zero
$LN3@gz_zero:

; 160  :     }
; 161  :     return 0;

  00095	33 c0		 xor	 eax, eax
$LN14@gz_zero:
  00097	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 162  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN11@gz_zero:

; 158  :             return -1;

  000ac	83 c8 ff	 or	 eax, -1
  000af	eb e6		 jmp	 SHORT $LN14@gz_zero
gz_zero	ENDP
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN12
	DD	imagerel $LN12+194
	DD	imagerel $unwind$gzclose_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzclose_w
_TEXT	SEGMENT
file$ = 48
gzclose_w PROC						; COMDAT

; 529  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 530  :     int ret = Z_OK;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 531  :     gz_statep state;
; 532  : 
; 533  :     /* get internal structure */
; 534  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 10		 jne	 SHORT $LN8@gzclose_w
$LN11@gzclose_w:

; 535  :         return Z_STREAM_ERROR;

  00014	b8 fe ff ff ff	 mov	 eax, -2

; 564  :     return ret;
; 565  : }

  00019	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN8@gzclose_w:

; 536  :     state = (gz_statep)file;
; 537  : 
; 538  :     /* check that we're writing */
; 539  :     if (state->mode != GZ_WRITE)

  00024	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H

; 540  :         return Z_STREAM_ERROR;

  0002b	75 e7		 jne	 SHORT $LN11@gzclose_w

; 541  : 
; 542  :     /* check for seek request */
; 543  :     if (state->seek) {

  0002d	39 79 68	 cmp	 DWORD PTR [rcx+104], edi
  00030	74 14		 je	 SHORT $LN5@gzclose_w

; 544  :         state->seek = 0;
; 545  :         if (gz_zero(state, state->skip) == -1)

  00032	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00036	89 79 68	 mov	 DWORD PTR [rcx+104], edi
  00039	e8 00 00 00 00	 call	 gz_zero
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	75 03		 jne	 SHORT $LN5@gzclose_w

; 546  :             ret = state->err;

  00043	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN5@gzclose_w:

; 547  :     }
; 548  : 
; 549  :     /* flush, free memory, and close file */
; 550  :     if (state->size) {

  00046	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0004a	74 38		 je	 SHORT $LN4@gzclose_w

; 551  :         if (gz_comp(state, Z_FINISH) == -1)

  0004c	ba 04 00 00 00	 mov	 edx, 4
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 gz_comp
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 03		 jne	 SHORT $LN3@gzclose_w

; 552  :             ret = state->err;

  0005e	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN3@gzclose_w:

; 553  :         if (!state->direct) {

  00061	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00065	75 13		 jne	 SHORT $LN2@gzclose_w

; 554  :             (void)deflateEnd(&(state->strm));

  00067	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  0006b	e8 00 00 00 00	 call	 deflateEnd

; 555  :             free(state->out);

  00070	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@gzclose_w:

; 556  :         }
; 557  :         free(state->in);

  0007a	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gzclose_w:

; 558  :     }
; 559  :     gz_error(state, Z_OK, NULL);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	33 d2		 xor	 edx, edx
  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 gz_error

; 560  :     free(state->path);

  00091	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 561  :     if (close(state->fd) == -1)

  0009b	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  000a4	83 c9 ff	 or	 ecx, -1
  000a7	3b c1		 cmp	 eax, ecx
  000a9	0f 44 f9	 cmove	 edi, ecx

; 562  :         ret = Z_ERRNO;
; 563  :     free(state);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 564  :     return ret;
; 565  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	8b c7		 mov	 eax, edi
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
PUBLIC	gzsetparams
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN13
	DD	imagerel $LN13+197
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 083b01H
	DD	06543bH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzsetparams
_TEXT	SEGMENT
file$ = 48
level$ = 56
strategy$ = 64
gzsetparams PROC					; COMDAT

; 489  : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f8	 mov	 edi, r8d
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 490  :     gz_statep state;
; 491  :     z_streamp strm;
; 492  : 
; 493  :     /* get internal structure */
; 494  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 13		 jne	 SHORT $LN8@gzsetparam

; 495  :         return Z_STREAM_ERROR;

  0001c	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 524  : }

  0001f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00024	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN8@gzsetparam:

; 496  :     state = (gz_statep)file;
; 497  :     strm = &(state->strm);
; 498  : 
; 499  :     /* check that we're writing and that there's no error */
; 500  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0002f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00036	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003b	75 6e		 jne	 SHORT $LN6@gzsetparam
  0003d	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00041	75 68		 jne	 SHORT $LN6@gzsetparam

; 502  : 
; 503  :     /* if no change is requested, then do nothing */
; 504  :     if (level == state->level && strategy == state->strategy)

  00043	3b 51 58	 cmp	 edx, DWORD PTR [rcx+88]
  00046	75 06		 jne	 SHORT $LN5@gzsetparam
  00048	44 3b 41 5c	 cmp	 r8d, DWORD PTR [rcx+92]

; 505  :         return Z_OK;

  0004c	74 59		 je	 SHORT $LN12@gzsetparam
$LN5@gzsetparam:

; 506  : 
; 507  :     /* check for seek request */
; 508  :     if (state->seek) {

  0004e	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00052	74 19		 je	 SHORT $LN3@gzsetparam

; 509  :         state->seek = 0;
; 510  :         if (gz_zero(state, state->skip) == -1)

  00054	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00058	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005f	e8 00 00 00 00	 call	 gz_zero
  00064	83 f8 ff	 cmp	 eax, -1
  00067	75 04		 jne	 SHORT $LN3@gzsetparam

; 511  :             return -1;

  00069	0b c0		 or	 eax, eax
  0006b	eb 43		 jmp	 SHORT $LN11@gzsetparam
$LN3@gzsetparam:

; 512  :     }
; 513  : 
; 514  :     /* change compression parameters for subsequent input */
; 515  :     if (state->size) {

  0006d	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  00071	74 2e		 je	 SHORT $LN2@gzsetparam

; 516  :         /* flush previous input with previous parameters before changing */
; 517  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00073	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  0007a	74 17		 je	 SHORT $LN1@gzsetparam
  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 gz_comp
  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 05		 jne	 SHORT $LN1@gzsetparam

; 518  :             return state->err;

  0008e	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]
  00091	eb 1d		 jmp	 SHORT $LN11@gzsetparam
$LN1@gzsetparam:

; 519  :         deflateParams(strm, level, strategy);

  00093	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  00097	44 8b c7	 mov	 r8d, edi
  0009a	8b d6		 mov	 edx, esi
  0009c	e8 00 00 00 00	 call	 deflateParams
$LN2@gzsetparam:

; 520  :     }
; 521  :     state->level = level;

  000a1	89 73 58	 mov	 DWORD PTR [rbx+88], esi

; 522  :     state->strategy = strategy;

  000a4	89 7b 5c	 mov	 DWORD PTR [rbx+92], edi
$LN12@gzsetparam:

; 523  :     return Z_OK;

  000a7	33 c0		 xor	 eax, eax
  000a9	eb 05		 jmp	 SHORT $LN11@gzsetparam
$LN6@gzsetparam:

; 501  :         return Z_STREAM_ERROR;

  000ab	b8 fe ff ff ff	 mov	 eax, -2
$LN11@gzsetparam:
  000b0	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 524  : }

  000b5	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ba	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
PUBLIC	gzflush
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN11
	DD	imagerel $LN11+121
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzflush
_TEXT	SEGMENT
file$ = 48
flush$ = 56
gzflush	PROC						; COMDAT

; 456  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 457  :     gz_statep state;
; 458  : 
; 459  :     /* get internal structure */
; 460  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 0e		 jne	 SHORT $LN7@gzflush
$LN10@gzflush:

; 461  :         return -1;

  00014	83 c8 ff	 or	 eax, -1

; 482  : }

  00017	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
$LN7@gzflush:

; 462  :     state = (gz_statep)file;
; 463  : 
; 464  :     /* check that we're writing and that there's no error */
; 465  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00022	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00029	75 3e		 jne	 SHORT $LN5@gzflush
  0002b	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0002f	75 38		 jne	 SHORT $LN5@gzflush

; 467  : 
; 468  :     /* check flush parameter */
; 469  :     if (flush < 0 || flush > Z_FINISH)

  00031	83 fa 04	 cmp	 edx, 4
  00034	77 33		 ja	 SHORT $LN5@gzflush

; 470  :         return Z_STREAM_ERROR;
; 471  : 
; 472  :     /* check for seek request */
; 473  :     if (state->seek) {

  00036	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  0003a	74 15		 je	 SHORT $LN1@gzflush

; 474  :         state->seek = 0;
; 475  :         if (gz_zero(state, state->skip) == -1)

  0003c	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00040	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00047	e8 00 00 00 00	 call	 gz_zero
  0004c	83 f8 ff	 cmp	 eax, -1

; 476  :             return -1;

  0004f	74 c3		 je	 SHORT $LN10@gzflush
$LN1@gzflush:

; 477  :     }
; 478  : 
; 479  :     /* compress remaining data with requested flush */
; 480  :     gz_comp(state, flush);

  00051	8b d7		 mov	 edx, edi
  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 gz_comp

; 481  :     return state->err;

  0005b	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]

; 482  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN5@gzflush:

; 466  :         return Z_STREAM_ERROR;

  00069	b8 fe ff ff ff	 mov	 eax, -2

; 482  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
PUBLIC	gzprintf
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN15
	DD	imagerel $LN15+134
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzprintf DD imagerel $LN15+134
	DD	imagerel $LN15+237
	DD	imagerel $chain$1$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzprintf DD imagerel $LN15+237
	DD	imagerel $LN15+255
	DD	imagerel $chain$3$gzprintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzprintf DD 040021H
	DD	047400H
	DD	056400H
	DD	imagerel $LN15
	DD	imagerel $LN15+134
	DD	imagerel $unwind$gzprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzprintf DD 042421H
	DD	047424H
	DD	056405H
	DD	imagerel $LN15
	DD	imagerel $LN15+134
	DD	imagerel $unwind$gzprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 021401H
	DD	030105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzprintf
_TEXT	SEGMENT
file$ = 64
format$ = 72
gzprintf PROC						; COMDAT

; 304  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	53		 push	 rbx
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b d9	 mov	 rbx, rcx

; 305  :     int size, len;
; 306  :     gz_statep state;
; 307  :     z_streamp strm;
; 308  :     va_list va;
; 309  : 
; 310  :     /* get internal structure */
; 311  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 09		 jne	 SHORT $LN9@gzprintf

; 312  :         return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 369  : }

  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN9@gzprintf:

; 313  :     state = (gz_statep)file;
; 314  :     strm = &(state->strm);
; 315  : 
; 316  :     /* check that we're writing and that there's no error */
; 317  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0002c	75 16		 jne	 SHORT $LN14@gzprintf
  0002e	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00032	75 10		 jne	 SHORT $LN14@gzprintf

; 318  :         return 0;
; 319  : 
; 320  :     /* make sure we have some buffer space */
; 321  :     if (state->size == 0 && gz_init(state) == -1)

  00034	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00038	75 12		 jne	 SHORT $LN6@gzprintf
  0003a	e8 00 00 00 00	 call	 gz_init
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	75 08		 jne	 SHORT $LN6@gzprintf
$LN14@gzprintf:

; 322  :         return 0;

  00044	33 c0		 xor	 eax, eax

; 369  : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
$LN6@gzprintf:

; 323  : 
; 324  :     /* check for seek request */
; 325  :     if (state->seek) {

  0004c	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00050	74 18		 je	 SHORT $LN4@gzprintf

; 326  :         state->seek = 0;
; 327  :         if (gz_zero(state, state->skip) == -1)

  00052	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00056	48 8b cb	 mov	 rcx, rbx
  00059	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [rbx+104], 0
  00060	e8 00 00 00 00	 call	 gz_zero
  00065	83 f8 ff	 cmp	 eax, -1

; 328  :             return 0;

  00068	74 da		 je	 SHORT $LN14@gzprintf
$LN4@gzprintf:

; 329  :     }
; 330  : 
; 331  :     /* consume whatever's left in the input buffer */
; 332  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0006a	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00071	74 0f		 je	 SHORT $LN3@gzprintf
  00073	33 d2		 xor	 edx, edx
  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 gz_comp
  0007d	83 f8 ff	 cmp	 eax, -1

; 333  :         return 0;

  00080	74 c2		 je	 SHORT $LN14@gzprintf
$LN3@gzprintf:

; 334  : 
; 335  :     /* do the printf() into the input buffer, put length in len */
; 336  :     size = (int)(state->size);
; 337  :     state->in[size - 1] = 0;

  00082	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00086	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0008b	48 63 73 28	 movsxd	 rsi, DWORD PTR [rbx+40]
  0008f	c6 44 30 ff 00	 mov	 BYTE PTR [rax+rsi-1], 0

; 338  :     va_start(va, format);
; 339  : #ifdef NO_vsnprintf
; 340  : #  ifdef HAS_vsprintf_void
; 341  :     (void)vsprintf((char *)(state->in), format, va);
; 342  :     va_end(va);
; 343  :     for (len = 0; len < size; len++)
; 344  :         if (state->in[len] == 0) break;
; 345  : #  else
; 346  :     len = vsprintf((char *)(state->in), format, va);
; 347  :     va_end(va);
; 348  : #  endif
; 349  : #else
; 350  : #  ifdef HAS_vsnprintf_void
; 351  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 352  :     va_end(va);
; 353  :     len = strlen((char *)(state->in));
; 354  : #  else
; 355  :     len = vsnprintf((char *)(state->in), size, format, va);

  00094	4c 8b 44 24 48	 mov	 r8, QWORD PTR format$[rsp]
  00099	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0009d	4c 8d 4c 24 50	 lea	 r9, QWORD PTR format$[rsp+8]
  000a2	48 8b d6	 mov	 rdx, rsi
  000a5	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_vsnprintf
  000b0	4c 63 d8	 movsxd	 r11, eax

; 356  :     va_end(va);
; 357  : #  endif
; 358  : #endif
; 359  : 
; 360  :     /* check that printf() results fit in buffer */
; 361  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000b3	85 c0		 test	 eax, eax
  000b5	7e 36		 jle	 SHORT $LN1@gzprintf
  000b7	44 3b de	 cmp	 r11d, esi
  000ba	7d 31		 jge	 SHORT $LN1@gzprintf
  000bc	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000c0	80 7c 31 ff 00	 cmp	 BYTE PTR [rcx+rsi-1], 0
  000c5	75 26		 jne	 SHORT $LN1@gzprintf

; 363  : 
; 364  :     /* update buffer and position, defer compression until needed */
; 365  :     strm->avail_in = (unsigned)len;

  000c7	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  000cc	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000d1	44 89 9b 80 00
	00 00		 mov	 DWORD PTR [rbx+128], r11d

; 366  :     strm->next_in = state->in;

  000d8	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]

; 367  :     state->x.pos += len;
; 368  :     return len;

  000dc	41 8b c3	 mov	 eax, r11d
  000df	48 89 4b 78	 mov	 QWORD PTR [rbx+120], rcx
  000e3	4c 01 5b 10	 add	 QWORD PTR [rbx+16], r11

; 369  : }

  000e7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
$LN1@gzprintf:
  000ed	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  000f2	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 362  :         return 0;

  000f7	33 c0		 xor	 eax, eax

; 369  : }

  000f9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fd	5b		 pop	 rbx
  000fe	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
PUBLIC	gzwrite
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN28
	DD	imagerel $LN28+312
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 0a9101H
	DD	097491H
	DD	08348cH
	DD	0a540eH
	DD	0d00a320eH
	DD	06006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzwrite
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzwrite	PROC						; COMDAT

; 169  : {

$LN28:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	41 8b e8	 mov	 ebp, r8d
  00011	4c 8b e2	 mov	 r12, rdx
  00014	48 8b f1	 mov	 rsi, rcx

; 170  :     unsigned put = len;

  00017	45 8b e8	 mov	 r13d, r8d

; 171  :     unsigned n;
; 172  :     gz_statep state;
; 173  :     z_streamp strm;
; 174  : 
; 175  :     /* get internal structure */
; 176  :     if (file == NULL)

  0001a	48 85 c9	 test	 rcx, rcx

; 177  :         return 0;

  0001d	74 24		 je	 SHORT $LN27@gzwrite

; 178  :     state = (gz_statep)file;
; 179  :     strm = &(state->strm);
; 180  : 
; 181  :     /* check that we're writing and that there's no error */
; 182  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0001f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00026	75 1b		 jne	 SHORT $LN27@gzwrite
  00028	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0002c	75 15		 jne	 SHORT $LN27@gzwrite

; 183  :         return 0;
; 184  : 
; 185  :     /* since an int is returned, make sure len fits in one, otherwise return
; 186  :        with an error (this avoids the flaw in the interface) */
; 187  :     if ((int)len < 0) {

  0002e	85 ed		 test	 ebp, ebp
  00030	79 22		 jns	 SHORT $LN15@gzwrite

; 188  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00039	ba fd ff ff ff	 mov	 edx, -3
  0003e	e8 00 00 00 00	 call	 gz_error
$LN27@gzwrite:

; 189  :         return 0;

  00043	33 c0		 xor	 eax, eax

; 240  : }

  00045	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	41 5d		 pop	 r13
  00050	41 5c		 pop	 r12
  00052	5e		 pop	 rsi
  00053	c3		 ret	 0
$LN15@gzwrite:

; 190  :     }
; 191  : 
; 192  :     /* if len is zero, avoid unnecessary operations */
; 193  :     if (len == 0)

  00054	45 85 c0	 test	 r8d, r8d

; 194  :         return 0;

  00057	74 ea		 je	 SHORT $LN27@gzwrite

; 195  : 
; 196  :     /* allocate memory if this is the first time through */
; 197  :     if (state->size == 0 && gz_init(state) == -1)

  00059	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0005d	75 0a		 jne	 SHORT $LN13@gzwrite
  0005f	e8 00 00 00 00	 call	 gz_init
  00064	83 f8 ff	 cmp	 eax, -1

; 198  :         return 0;

  00067	74 da		 je	 SHORT $LN27@gzwrite
$LN13@gzwrite:

; 199  : 
; 200  :     /* check for seek request */
; 201  :     if (state->seek) {

  00069	83 7e 68 00	 cmp	 DWORD PTR [rsi+104], 0
  0006d	74 18		 je	 SHORT $LN11@gzwrite

; 202  :         state->seek = 0;
; 203  :         if (gz_zero(state, state->skip) == -1)

  0006f	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00073	48 8b ce	 mov	 rcx, rsi
  00076	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [rsi+104], 0
  0007d	e8 00 00 00 00	 call	 gz_zero
  00082	83 f8 ff	 cmp	 eax, -1

; 204  :             return 0;

  00085	74 bc		 je	 SHORT $LN27@gzwrite
$LN11@gzwrite:
  00087	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0008c	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 205  :     }
; 206  : 
; 207  :     /* for small len, copy to input buffer, otherwise compress directly */
; 208  :     if (len < state->size) {

  00091	3b 6e 28	 cmp	 ebp, DWORD PTR [rsi+40]
  00094	73 51		 jae	 SHORT $LN10@gzwrite
$LL9@gzwrite:

; 209  :         /* copy to input buffer, compress when full */
; 210  :         do {
; 211  :             if (strm->avail_in == 0)

  00096	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [rsi+128]
  0009c	85 c9		 test	 ecx, ecx
  0009e	75 08		 jne	 SHORT $LN6@gzwrite

; 212  :                 strm->next_in = state->in;

  000a0	48 8b 46 30	 mov	 rax, QWORD PTR [rsi+48]
  000a4	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax
$LN6@gzwrite:

; 213  :             n = state->size - strm->avail_in;

  000a8	8b 7e 28	 mov	 edi, DWORD PTR [rsi+40]

; 214  :             if (n > len)
; 215  :                 n = len;
; 216  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  000ab	49 8b d4	 mov	 rdx, r12
  000ae	2b f9		 sub	 edi, ecx
  000b0	3b fd		 cmp	 edi, ebp
  000b2	0f 47 fd	 cmova	 edi, ebp
  000b5	48 03 4e 78	 add	 rcx, QWORD PTR [rsi+120]
  000b9	44 8b c7	 mov	 r8d, edi
  000bc	8b df		 mov	 ebx, edi
  000be	e8 00 00 00 00	 call	 memcpy

; 217  :             strm->avail_in += n;

  000c3	01 be 80 00 00
	00		 add	 DWORD PTR [rsi+128], edi

; 218  :             state->x.pos += n;

  000c9	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 219  :             buf = (char *)buf + n;

  000cd	4c 03 e3	 add	 r12, rbx

; 220  :             len -= n;

  000d0	2b ef		 sub	 ebp, edi

; 221  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000d2	74 48		 je	 SHORT $LN1@gzwrite
  000d4	33 d2		 xor	 edx, edx
  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	e8 00 00 00 00	 call	 gz_comp
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	75 b3		 jne	 SHORT $LL9@gzwrite
$LN26@gzwrite:

; 222  :                 return 0;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 38		 jmp	 SHORT $LN25@gzwrite
$LN10@gzwrite:

; 223  :         } while (len);
; 224  :     }
; 225  :     else {
; 226  :         /* consume whatever's left in the input buffer */
; 227  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000e7	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  000ee	74 0f		 je	 SHORT $LN2@gzwrite
  000f0	33 d2		 xor	 edx, edx
  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	e8 00 00 00 00	 call	 gz_comp
  000fa	83 f8 ff	 cmp	 eax, -1

; 228  :             return 0;

  000fd	74 e4		 je	 SHORT $LN26@gzwrite
$LN2@gzwrite:

; 229  : 
; 230  :         /* directly compress user buffer to file */
; 231  :         strm->avail_in = len;

  000ff	89 ae 80 00 00
	00		 mov	 DWORD PTR [rsi+128], ebp

; 232  :         strm->next_in = (voidp)buf;

  00105	4c 89 66 78	 mov	 QWORD PTR [rsi+120], r12

; 233  :         state->x.pos += len;

  00109	48 01 6e 10	 add	 QWORD PTR [rsi+16], rbp

; 234  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  0010d	33 d2		 xor	 edx, edx
  0010f	48 8b ce	 mov	 rcx, rsi
  00112	e8 00 00 00 00	 call	 gz_comp
  00117	83 f8 ff	 cmp	 eax, -1

; 235  :             return 0;

  0011a	74 c7		 je	 SHORT $LN26@gzwrite
$LN1@gzwrite:

; 236  :     }
; 237  : 
; 238  :     /* input was all buffered or compressed (put will fit in int) */
; 239  :     return (int)put;

  0011c	41 8b c5	 mov	 eax, r13d
$LN25@gzwrite:
  0011f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00124	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 240  : }

  00129	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0012e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00132	41 5d		 pop	 r13
  00134	41 5c		 pop	 r12
  00136	5e		 pop	 rsi
  00137	c3		 ret	 0
gzwrite	ENDP
PUBLIC	gzputs
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
str$ = 56
gzputs	PROC						; COMDAT

; 289  : {

$LN5:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c9	 mov	 r9, rcx

; 290  :     int ret;
; 291  :     unsigned len;
; 292  : 
; 293  :     /* write string */
; 294  :     len = (unsigned)strlen(str);

  00009	48 83 c9 ff	 or	 rcx, -1
  0000d	33 c0		 xor	 eax, eax
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	f2 ae		 repne scasb
  00014	48 f7 d1	 not	 rcx

; 295  :     ret = gzwrite(file, str, len);

  00017	44 8d 41 ff	 lea	 r8d, DWORD PTR [rcx-1]
  0001b	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
  0001f	49 8b c9	 mov	 rcx, r9
  00022	e8 00 00 00 00	 call	 gzwrite

; 296  :     return ret == 0 && len != 0 ? -1 : ret;

  00027	85 c0		 test	 eax, eax
  00029	75 07		 jne	 SHORT $LN3@gzputs
  0002b	85 ff		 test	 edi, edi
  0002d	74 03		 je	 SHORT $LN3@gzputs
  0002f	83 c8 ff	 or	 eax, -1
$LN3@gzputs:

; 297  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
PUBLIC	gzputc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN12
	DD	imagerel $LN12+161
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gzputc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
c$ = 56
gzputc	PROC						; COMDAT

; 246  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 247  :     unsigned char buf[1];
; 248  :     gz_statep state;
; 249  :     z_streamp strm;
; 250  : 
; 251  :     /* get internal structure */
; 252  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx

; 253  :         return -1;

  00012	74 7f		 je	 SHORT $LN6@gzputc

; 254  :     state = (gz_statep)file;
; 255  :     strm = &(state->strm);
; 256  : 
; 257  :     /* check that we're writing and that there's no error */
; 258  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00014	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001b	75 76		 jne	 SHORT $LN6@gzputc
  0001d	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00021	75 70		 jne	 SHORT $LN6@gzputc

; 260  : 
; 261  :     /* check for seek request */
; 262  :     if (state->seek) {

  00023	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00027	74 15		 je	 SHORT $LN4@gzputc

; 263  :         state->seek = 0;
; 264  :         if (gz_zero(state, state->skip) == -1)

  00029	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0002d	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00034	e8 00 00 00 00	 call	 gz_zero
  00039	83 f8 ff	 cmp	 eax, -1

; 265  :             return -1;

  0003c	74 55		 je	 SHORT $LN6@gzputc
$LN4@gzputc:

; 266  :     }
; 267  : 
; 268  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 269  :        initialized) */
; 270  :     if (strm->avail_in < state->size) {

  0003e	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00044	3b 4b 28	 cmp	 ecx, DWORD PTR [rbx+40]
  00047	73 2d		 jae	 SHORT $LN3@gzputc

; 271  :         if (strm->avail_in == 0)

  00049	85 c9		 test	 ecx, ecx
  0004b	75 08		 jne	 SHORT $LN2@gzputc

; 272  :             strm->next_in = state->in;

  0004d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00051	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN2@gzputc:

; 273  :         strm->next_in[strm->avail_in++] = c;

  00055	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00059	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  0005d	ff 83 80 00 00
	00		 inc	 DWORD PTR [rbx+128]

; 274  :         state->x.pos++;

  00063	48 ff 43 10	 inc	 QWORD PTR [rbx+16]
$LN11@gzputc:

; 275  :         return c & 0xff;

  00067	40 0f b6 c7	 movzx	 eax, dil

; 283  : }

  0006b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
$LN3@gzputc:

; 276  :     }
; 277  : 
; 278  :     /* no room in buffer or not initialized, use gz_write() */
; 279  :     buf[0] = c;
; 280  :     if (gzwrite(file, buf, 1) != 1)

  00076	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  0007b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00081	48 8b cb	 mov	 rcx, rbx
  00084	40 88 7c 24 30	 mov	 BYTE PTR buf$[rsp], dil
  00089	e8 00 00 00 00	 call	 gzwrite
  0008e	83 f8 01	 cmp	 eax, 1

; 281  :         return -1;
; 282  :     return c & 0xff;

  00091	74 d4		 je	 SHORT $LN11@gzputc
$LN6@gzputc:

; 259  :         return -1;

  00093	83 c8 ff	 or	 eax, -1

; 283  : }

  00096	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
gzputc	ENDP
END
