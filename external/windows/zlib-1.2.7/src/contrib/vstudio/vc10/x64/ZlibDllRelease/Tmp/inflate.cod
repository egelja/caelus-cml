; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	inflateMark
; Function compile flags: /Ogtpy
; File c:\users\darrin\downloads\zlib127\zlib-1.2.7\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 8
inflateMark PROC					; COMDAT

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN1@inflateMar
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 3e		 je	 SHORT $LN1@inflateMar

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  0000e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00010	83 f9 0f	 cmp	 ecx, 15
  00013	75 0f		 jne	 SHORT $LN7@inflateMar
  00015	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00018	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  0001e	c1 e0 10	 shl	 eax, 16
  00021	03 c1		 add	 eax, ecx

; 1496 : }

  00023	c3		 ret	 0
$LN7@inflateMar:

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  00024	83 f9 18	 cmp	 ecx, 24
  00027	75 15		 jne	 SHORT $LN5@inflateMar
  00029	8b 88 e0 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7136]
  0002f	2b 48 48	 sub	 ecx, DWORD PTR [rax+72]
  00032	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00038	c1 e0 10	 shl	 eax, 16
  0003b	03 c1		 add	 eax, ecx

; 1496 : }

  0003d	c3		 ret	 0
$LN5@inflateMar:

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     return ((long)(state->back) << 16) +
; 1494 :         (state->mode == COPY ? state->length :
; 1495 :             (state->mode == MATCH ? state->was - state->length : 0));

  0003e	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00044	33 c9		 xor	 ecx, ecx
  00046	c1 e0 10	 shl	 eax, 16
  00049	03 c1		 add	 eax, ecx

; 1496 : }

  0004b	c3		 ret	 0
$LN1@inflateMar:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  0004c	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1496 : }

  00051	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
PUBLIC	inflateUndermine
; Function compile flags: /Ogtpy
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 8
subvert$ = 16
inflateUndermine PROC					; COMDAT

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 19		 je	 SHORT $LN1@inflateUnd
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 10		 je	 SHORT $LN1@inflateUnd

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     state->sane = !subvert;
; 1478 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1479 :     return Z_OK;
; 1480 : #else
; 1481 :     state->sane = 1;

  0000e	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1482 :     return Z_DATA_ERROR;

  00018	b8 fd ff ff ff	 mov	 eax, -3

; 1483 : #endif
; 1484 : }

  0001d	c3		 ret	 0
$LN1@inflateUnd:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001e	b8 fe ff ff ff	 mov	 eax, -2

; 1483 : #endif
; 1484 : }

  00023	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
PUBLIC	inflateCopy
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateCopy DD imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN13+114
	DD	imagerel $LN13+171
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN13+171
	DD	imagerel $LN13+190
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN13+190
	DD	imagerel $LN13+384
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN13+384
	DD	imagerel $LN13+398
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 060021H
	DD	0ad400H
	DD	096400H
	DD	085400H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 021H
	DD	imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 020521H
	DD	085405H
	DD	imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateCopy DD 040a21H
	DD	0ad40aH
	DD	096405H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 040901H
	DD	0c0053209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1425 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8b da	 mov	 rbx, rdx
  0000c	4c 8b e1	 mov	 r12, rcx

; 1426 :     struct inflate_state FAR *state;
; 1427 :     struct inflate_state FAR *copy;
; 1428 :     unsigned char FAR *window;
; 1429 :     unsigned wsize;
; 1430 : 
; 1431 :     /* check input */
; 1432 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1433 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 68 01 00
	00		 je	 $LN6@inflateCop
  00018	48 85 d2	 test	 rdx, rdx
  0001b	0f 84 5f 01 00
	00		 je	 $LN6@inflateCop
  00021	48 8b 7a 28	 mov	 rdi, QWORD PTR [rdx+40]
  00025	48 85 ff	 test	 rdi, rdi
  00028	0f 84 52 01 00
	00		 je	 $LN6@inflateCop
  0002e	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00032	48 85 c0	 test	 rax, rax
  00035	0f 84 45 01 00
	00		 je	 $LN6@inflateCop
  0003b	48 83 7a 38 00	 cmp	 QWORD PTR [rdx+56], 0
  00040	0f 84 3a 01 00
	00		 je	 $LN6@inflateCop

; 1435 :     state = (struct inflate_state FAR *)source->state;
; 1436 : 
; 1437 :     /* allocate space */
; 1438 :     copy = (struct inflate_state FAR *)
; 1439 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00046	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004f	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  00054	41 bd 01 00 00
	00		 mov	 r13d, 1
  0005a	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00060	41 8b d5	 mov	 edx, r13d
  00063	ff d0		 call	 rax
  00065	48 8b f0	 mov	 rsi, rax

; 1440 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00068	48 85 c0	 test	 rax, rax
  0006b	75 05		 jne	 SHORT $LN5@inflateCop
  0006d	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
  00070	eb 39		 jmp	 SHORT $LN11@inflateCop
$LN5@inflateCop:
  00072	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1441 :     window = Z_NULL;

  00077	33 ed		 xor	 ebp, ebp

; 1442 :     if (state->window != Z_NULL) {

  00079	48 39 6f 38	 cmp	 QWORD PTR [rdi+56], rbp
  0007d	74 3f		 je	 SHORT $LN3@inflateCop

; 1443 :         window = (unsigned char FAR *)
; 1444 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007f	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  00082	41 8b d5	 mov	 edx, r13d
  00085	45 8b c5	 mov	 r8d, r13d
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0008e	ff 53 30	 call	 QWORD PTR [rbx+48]
  00091	48 8b e8	 mov	 rbp, rax

; 1445 :         if (window == Z_NULL) {

  00094	48 85 c0	 test	 rax, rax
  00097	75 25		 jne	 SHORT $LN3@inflateCop

; 1446 :             ZFREE(source, copy);

  00099	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1447 :             return Z_MEM_ERROR;

  000a3	8d 45 fc	 lea	 eax, QWORD PTR [rbp-4]
$LN12@inflateCop:
  000a6	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN11@inflateCop:
  000ab	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b0	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 1467 : }

  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	41 5c		 pop	 r12
  000bb	5f		 pop	 rdi
  000bc	5b		 pop	 rbx
  000bd	c3		 ret	 0
$LN3@inflateCop:

; 1448 :         }
; 1449 :     }
; 1450 : 
; 1451 :     /* copy state */
; 1452 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000be	49 8b cc	 mov	 rcx, r12
  000c1	48 8b d3	 mov	 rdx, rbx
  000c4	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  000ca	e8 00 00 00 00	 call	 memcpy

; 1453 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000cf	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000d5	48 8b d7	 mov	 rdx, rdi
  000d8	48 8b ce	 mov	 rcx, rsi
  000db	e8 00 00 00 00	 call	 memcpy

; 1454 :     if (state->lencode >= state->codes &&
; 1455 :         state->lencode <= state->codes + ENOUGH - 1) {

  000e0	4c 8b 5f 58	 mov	 r11, QWORD PTR [rdi+88]
  000e4	48 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [rdi+1352]
  000eb	4c 3b d8	 cmp	 r11, rax
  000ee	72 43		 jb	 SHORT $LN2@inflateCop
  000f0	48 8d 87 d4 1b
	00 00		 lea	 rax, QWORD PTR [rdi+7124]
  000f7	4c 3b d8	 cmp	 r11, rax
  000fa	77 37		 ja	 SHORT $LN2@inflateCop

; 1456 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000fc	4c 2b df	 sub	 r11, rdi
  000ff	49 81 eb 48 05
	00 00		 sub	 r11, 1352		; 00000548H
  00106	49 c1 fb 02	 sar	 r11, 2
  0010a	4a 8d 84 9e 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+r11*4+1352]
  00112	48 89 46 58	 mov	 QWORD PTR [rsi+88], rax

; 1457 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00116	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0011a	48 2b c7	 sub	 rax, rdi
  0011d	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00123	48 c1 f8 02	 sar	 rax, 2
  00127	48 8d 84 86 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+rax*4+1352]
  0012f	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN2@inflateCop:

; 1458 :     }
; 1459 :     copy->next = copy->codes + (state->next - state->codes);

  00133	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0013a	48 2b c7	 sub	 rax, rdi
  0013d	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00143	48 c1 f8 02	 sar	 rax, 2
  00147	48 8d 84 86 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+rax*4+1352]
  0014f	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 1460 :     if (window != Z_NULL) {

  00156	48 85 ed	 test	 rbp, rbp
  00159	74 15		 je	 SHORT $LN1@inflateCop

; 1461 :         wsize = 1U << state->wbits;

  0015b	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]

; 1462 :         zmemcpy(window, state->window, wsize);

  0015e	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00162	41 d3 e5	 shl	 r13d, cl
  00165	48 8b cd	 mov	 rcx, rbp
  00168	45 8b c5	 mov	 r8d, r13d
  0016b	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1463 :     }
; 1464 :     copy->window = window;

  00170	48 89 6e 38	 mov	 QWORD PTR [rsi+56], rbp

; 1465 :     dest->state = (struct internal_state FAR *)copy;
; 1466 :     return Z_OK;

  00174	33 c0		 xor	 eax, eax
  00176	49 89 74 24 28	 mov	 QWORD PTR [r12+40], rsi
  0017b	e9 26 ff ff ff	 jmp	 $LN12@inflateCop
$LN6@inflateCop:

; 1434 :         return Z_STREAM_ERROR;

  00180	b8 fe ff ff ff	 mov	 eax, -2

; 1467 : }

  00185	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00189	41 5c		 pop	 r12
  0018b	5f		 pop	 rdi
  0018c	5b		 pop	 rbx
  0018d	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
PUBLIC	inflateSyncPoint
; Function compile flags: /Ogtpy
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 8
inflateSyncPoint PROC					; COMDAT

; 1415 :     struct inflate_state FAR *state;
; 1416 : 
; 1417 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN1@inflateSyn
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN1@inflateSyn

; 1418 :     state = (struct inflate_state FAR *)strm->state;
; 1419 :     return state->mode == STORED && state->bits == 0;

  0000e	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00011	75 0c		 jne	 SHORT $LN5@inflateSyn
  00013	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00017	75 06		 jne	 SHORT $LN5@inflateSyn
  00019	b8 01 00 00 00	 mov	 eax, 1

; 1420 : }

  0001e	c3		 ret	 0
$LN5@inflateSyn:

; 1418 :     state = (struct inflate_state FAR *)strm->state;
; 1419 :     return state->mode == STORED && state->bits == 0;

  0001f	33 c0		 xor	 eax, eax

; 1420 : }

  00021	c3		 ret	 0
$LN1@inflateSyn:

; 1415 :     struct inflate_state FAR *state;
; 1416 : 
; 1417 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1420 : }

  00027	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+106
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1342 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1343 :     unsigned got;
; 1344 :     unsigned next;
; 1345 : 
; 1346 :     got = *have;

  00005	44 8b 09	 mov	 r9d, DWORD PTR [rcx]

; 1347 :     next = 0;

  00008	33 db		 xor	 ebx, ebx
  0000a	4c 8b d9	 mov	 r11, rcx
  0000d	44 8b d3	 mov	 r10d, ebx

; 1348 :     while (next < len && got < 4) {

  00010	45 85 c0	 test	 r8d, r8d
  00013	74 49		 je	 SHORT $LN11@syncsearch
$LL6@syncsearch:
  00015	41 83 f9 04	 cmp	 r9d, 4
  00019	73 37		 jae	 SHORT $LN12@syncsearch

; 1349 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001b	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  0001e	41 83 f9 02	 cmp	 r9d, 2
  00022	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00027	0f 42 c3	 cmovb	 eax, ebx
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 05		 jne	 SHORT $LN4@syncsearch

; 1350 :             got++;

  0002e	41 ff c1	 inc	 r9d
  00031	eb 14		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1351 :         else if (buf[next])

  00033	84 c9		 test	 cl, cl
  00035	74 05		 je	 SHORT $LN2@syncsearch

; 1352 :             got = 0;

  00037	44 8b cb	 mov	 r9d, ebx

; 1353 :         else

  0003a	eb 0b		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1354 :             got = 4 - got;

  0003c	b9 04 00 00 00	 mov	 ecx, 4
  00041	41 2b c9	 sub	 ecx, r9d
  00044	44 8b c9	 mov	 r9d, ecx
$LN1@syncsearch:

; 1355 :         next++;

  00047	41 ff c2	 inc	 r10d
  0004a	48 ff c2	 inc	 rdx
  0004d	45 3b d0	 cmp	 r10d, r8d
  00050	72 c3		 jb	 SHORT $LL6@syncsearch
$LN12@syncsearch:

; 1356 :     }
; 1357 :     *have = got;

  00052	45 89 0b	 mov	 DWORD PTR [r11], r9d

; 1358 :     return next;

  00055	41 8b c2	 mov	 eax, r10d

; 1359 : }

  00058	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005d	c3		 ret	 0
$LN11@syncsearch:
  0005e	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00063	44 89 09	 mov	 DWORD PTR [rcx], r9d
  00066	41 8b c2	 mov	 eax, r10d
  00069	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
PUBLIC	inflateGetHeader
; Function compile flags: /Ogtpy
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
inflateGetHeader PROC					; COMDAT

; 1314 :     struct inflate_state FAR *state;
; 1315 : 
; 1316 :     /* check state */
; 1317 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN2@inflateGet
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN2@inflateGet

; 1318 :     state = (struct inflate_state FAR *)strm->state;
; 1319 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0000e	f6 40 08 02	 test	 BYTE PTR [rax+8], 2
  00012	74 0e		 je	 SHORT $LN2@inflateGet

; 1320 : 
; 1321 :     /* save header structure */
; 1322 :     state->head = head;

  00014	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 1323 :     head->done = 0;

  00018	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1324 :     return Z_OK;

  0001f	33 c0		 xor	 eax, eax

; 1325 : }

  00021	c3		 ret	 0
$LN2@inflateGet:

; 1314 :     struct inflate_state FAR *state;
; 1315 : 
; 1316 :     /* check state */
; 1317 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1325 : }

  00027	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1255 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1256 :     struct inflate_state FAR *state;
; 1257 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3d		 je	 SHORT $LN2@inflateEnd
  0000e	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00012	48 85 c0	 test	 rax, rax
  00015	74 34		 je	 SHORT $LN2@inflateEnd
  00017	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 2b		 je	 SHORT $LN2@inflateEnd

; 1259 :     state = (struct inflate_state FAR *)strm->state;
; 1260 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00020	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00024	48 85 d2	 test	 rdx, rdx
  00027	74 07		 je	 SHORT $LN1@inflateEnd
  00029	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002d	41 ff d0	 call	 r8
$LN1@inflateEnd:

; 1261 :     ZFREE(strm, strm->state);

  00030	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00034	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1262 :     strm->state = Z_NULL;

  0003b	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1263 :     Tracev((stderr, "inflate: end\n"));
; 1264 :     return Z_OK;

  00043	33 c0		 xor	 eax, eax

; 1265 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@inflateEnd:

; 1258 :         return Z_STREAM_ERROR;

  0004b	b8 fe ff ff ff	 mov	 eax, -2

; 1265 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$updatewindow DD imagerel updatewindow+74
	DD	imagerel updatewindow+234
	DD	imagerel $chain$0$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$updatewindow DD imagerel updatewindow+234
	DD	imagerel updatewindow+255
	DD	imagerel $chain$1$updatewindow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$updatewindow DD 021H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$updatewindow DD 020521H
	DD	06c405H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
out$ = 56
updatewindow PROC					; COMDAT

; 381  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 382  :     struct inflate_state FAR *state;
; 383  :     unsigned copy, dist;
; 384  : 
; 385  :     state = (struct inflate_state FAR *)strm->state;

  00014	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00018	8b ea		 mov	 ebp, edx
  0001a	48 8b f1	 mov	 rsi, rcx

; 386  : 
; 387  :     /* if it hasn't been done already, allocate space for the window */
; 388  :     if (state->window == Z_NULL) {

  0001d	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  00022	bf 01 00 00 00	 mov	 edi, 1
  00027	75 21		 jne	 SHORT $LN9@updatewind

; 389  :         state->window = (unsigned char FAR *)
; 390  :                         ZALLOC(strm, 1U << state->wbits,
; 391  :                                sizeof(unsigned char));

  00029	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0002c	8b d7		 mov	 edx, edi
  0002e	44 8b c7	 mov	 r8d, edi
  00031	d3 e2		 shl	 edx, cl
  00033	48 8b 4e 40	 mov	 rcx, QWORD PTR [rsi+64]
  00037	ff 56 30	 call	 QWORD PTR [rsi+48]
  0003a	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 392  :         if (state->window == Z_NULL) return 1;

  0003e	48 85 c0	 test	 rax, rax
  00041	75 07		 jne	 SHORT $LN9@updatewind
  00043	8b c7		 mov	 eax, edi
  00045	e9 a0 00 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
  0004a	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12

; 393  :     }
; 394  : 
; 395  :     /* if window not in use yet, initialize */
; 396  :     if (state->wsize == 0) {

  0004f	45 33 e4	 xor	 r12d, r12d
  00052	44 39 63 2c	 cmp	 DWORD PTR [rbx+44], r12d
  00056	75 0c		 jne	 SHORT $LN8@updatewind

; 397  :         state->wsize = 1U << state->wbits;

  00058	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 398  :         state->wnext = 0;

  0005b	4c 89 63 30	 mov	 QWORD PTR [rbx+48], r12
  0005f	d3 e7		 shl	 edi, cl
  00061	89 7b 2c	 mov	 DWORD PTR [rbx+44], edi
$LN8@updatewind:

; 399  :         state->whave = 0;
; 400  :     }
; 401  : 
; 402  :     /* copy state->wsize or less output bytes into the circular window */
; 403  :     copy = out - strm->avail_out;

  00064	2b 6e 18	 sub	 ebp, DWORD PTR [rsi+24]

; 404  :     if (copy >= state->wsize) {

  00067	8b 7b 2c	 mov	 edi, DWORD PTR [rbx+44]

; 405  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  0006a	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  0006e	3b ef		 cmp	 ebp, edi
  00070	72 18		 jb	 SHORT $LN7@updatewind
  00072	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00076	44 8b c7	 mov	 r8d, edi
  00079	48 2b d7	 sub	 rdx, rdi
  0007c	e8 00 00 00 00	 call	 memcpy

; 406  :         state->wnext = 0;
; 407  :         state->whave = state->wsize;

  00081	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00084	44 89 63 34	 mov	 DWORD PTR [rbx+52], r12d

; 408  :     }
; 409  :     else {

  00088	eb 56		 jmp	 SHORT $LN13@updatewind
$LN7@updatewind:

; 410  :         dist = state->wsize - state->wnext;

  0008a	2b 7b 34	 sub	 edi, DWORD PTR [rbx+52]

; 411  :         if (dist > copy) dist = copy;
; 412  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  0008d	8b 4b 34	 mov	 ecx, DWORD PTR [rbx+52]
  00090	8b c5		 mov	 eax, ebp
  00092	3b fd		 cmp	 edi, ebp
  00094	0f 47 fd	 cmova	 edi, ebp
  00097	48 03 4b 38	 add	 rcx, QWORD PTR [rbx+56]
  0009b	48 2b d0	 sub	 rdx, rax
  0009e	44 8b c7	 mov	 r8d, edi
  000a1	e8 00 00 00 00	 call	 memcpy

; 413  :         copy -= dist;

  000a6	2b ef		 sub	 ebp, edi

; 414  :         if (copy) {

  000a8	74 1b		 je	 SHORT $LN4@updatewind

; 415  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000aa	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  000ae	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b2	44 8b c5	 mov	 r8d, ebp
  000b5	49 2b d0	 sub	 rdx, r8
  000b8	e8 00 00 00 00	 call	 memcpy

; 416  :             state->wnext = copy;
; 417  :             state->whave = state->wsize;

  000bd	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000c0	89 6b 34	 mov	 DWORD PTR [rbx+52], ebp

; 418  :         }
; 419  :         else {

  000c3	eb 1b		 jmp	 SHORT $LN13@updatewind
$LN4@updatewind:

; 420  :             state->wnext += dist;

  000c5	01 7b 34	 add	 DWORD PTR [rbx+52], edi

; 421  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c8	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000cb	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  000ce	3b c1		 cmp	 eax, ecx
  000d0	41 0f 44 c4	 cmove	 eax, r12d
  000d4	89 43 34	 mov	 DWORD PTR [rbx+52], eax

; 422  :             if (state->whave < state->wsize) state->whave += dist;

  000d7	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  000da	3b c1		 cmp	 eax, ecx
  000dc	73 05		 jae	 SHORT $LN1@updatewind
  000de	03 c7		 add	 eax, edi
$LN13@updatewind:
  000e0	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN1@updatewind:
  000e3	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 423  :         }
; 424  :     }
; 425  :     return 0;

  000e8	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 426  : }

  000ea	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ef	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
updatewindow ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 263  : #ifdef BUILDFIXED
; 264  :     static int virgin = 1;
; 265  :     static code *lenfix, *distfix;
; 266  :     static code fixed[544];
; 267  : 
; 268  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 269  :     if (virgin) {
; 270  :         unsigned sym, bits;
; 271  :         static code *next;
; 272  : 
; 273  :         /* literal/length table */
; 274  :         sym = 0;
; 275  :         while (sym < 144) state->lens[sym++] = 8;
; 276  :         while (sym < 256) state->lens[sym++] = 9;
; 277  :         while (sym < 280) state->lens[sym++] = 7;
; 278  :         while (sym < 288) state->lens[sym++] = 8;
; 279  :         next = fixed;
; 280  :         lenfix = next;
; 281  :         bits = 9;
; 282  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 283  : 
; 284  :         /* distance table */
; 285  :         sym = 0;
; 286  :         while (sym < 32) state->lens[sym++] = 5;
; 287  :         distfix = next;
; 288  :         bits = 5;
; 289  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 290  : 
; 291  :         /* do this just once */
; 292  :         virgin = 0;
; 293  :     }
; 294  : #else /* !BUILDFIXED */
; 295  : #   include "inffixed.h"
; 296  : #endif /* BUILDFIXED */
; 297  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 298  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 299  :     state->distcode = distfix;
; 300  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 301  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflatePrime
; Function compile flags: /Ogtpy
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
inflatePrime PROC					; COMDAT

; 233  : {

  00000	45 8b d8	 mov	 r11d, r8d

; 234  :     struct inflate_state FAR *state;
; 235  : 
; 236  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 45		 je	 SHORT $LN4@inflatePri
  00008	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3c		 je	 SHORT $LN4@inflatePri

; 237  :     state = (struct inflate_state FAR *)strm->state;
; 238  :     if (bits < 0) {

  00011	85 d2		 test	 edx, edx
  00013	79 07		 jns	 SHORT $LN3@inflatePri

; 239  :         state->hold = 0;

  00015	33 c0		 xor	 eax, eax
  00017	49 89 41 40	 mov	 QWORD PTR [r9+64], rax

; 248  : }

  0001b	c3		 ret	 0
$LN3@inflatePri:

; 240  :         state->bits = 0;
; 241  :         return Z_OK;
; 242  :     }
; 243  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0001c	83 fa 10	 cmp	 edx, 16
  0001f	7f 2c		 jg	 SHORT $LN4@inflatePri
  00021	45 8b 41 44	 mov	 r8d, DWORD PTR [r9+68]
  00025	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  00029	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  0002d	77 1e		 ja	 SHORT $LN4@inflatePri

; 244  :     value &= (1L << bits) - 1;

  0002f	8b ca		 mov	 ecx, edx
  00031	b8 01 00 00 00	 mov	 eax, 1

; 245  :     state->hold += value << state->bits;
; 246  :     state->bits += bits;

  00036	45 89 51 44	 mov	 DWORD PTR [r9+68], r10d
  0003a	d3 e0		 shl	 eax, cl
  0003c	41 8b c8	 mov	 ecx, r8d
  0003f	ff c8		 dec	 eax
  00041	41 23 c3	 and	 eax, r11d
  00044	d3 e0		 shl	 eax, cl
  00046	41 01 41 40	 add	 DWORD PTR [r9+64], eax

; 247  :     return Z_OK;

  0004a	33 c0		 xor	 eax, eax

; 248  : }

  0004c	c3		 ret	 0
$LN4@inflatePri:

; 234  :     struct inflate_state FAR *state;
; 235  : 
; 236  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2

; 248  : }

  00052	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
PUBLIC	inflateResetKeep
; Function compile flags: /Ogtpy
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 8
inflateResetKeep PROC					; COMDAT

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 6c		 je	 SHORT $LN2@inflateRes
  00005	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 63		 je	 SHORT $LN2@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00015	44 89 41 1c	 mov	 DWORD PTR [rcx+28], r8d
  00019	44 89 41 0c	 mov	 DWORD PTR [rcx+12], r8d

; 111  :     strm->msg = Z_NULL;

  0001d	4c 89 41 20	 mov	 QWORD PTR [rcx+32], r8

; 112  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00021	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  00024	85 c0		 test	 eax, eax
  00026	74 06		 je	 SHORT $LN1@inflateRes

; 113  :         strm->adler = state->wrap & 1;

  00028	83 e0 01	 and	 eax, 1
  0002b	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN1@inflateRes:

; 114  :     state->mode = HEAD;
; 115  :     state->last = 0;
; 116  :     state->havedict = 0;
; 117  :     state->dmax = 32768U;
; 118  :     state->head = Z_NULL;
; 119  :     state->hold = 0;
; 120  :     state->bits = 0;
; 121  :     state->lencode = state->distcode = state->next = state->codes;

  0002e	48 8d 82 48 05
	00 00		 lea	 rax, QWORD PTR [rdx+1352]
  00035	4c 89 02	 mov	 QWORD PTR [rdx], r8
  00038	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d
  0003c	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax
  00043	48 89 42 60	 mov	 QWORD PTR [rdx+96], rax
  00047	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 122  :     state->sane = 1;
; 123  :     state->back = -1;
; 124  :     Tracev((stderr, "inflate: reset\n"));
; 125  :     return Z_OK;

  0004b	33 c0		 xor	 eax, eax
  0004d	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [rdx+20], 32768 ; 00008000H
  00054	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8
  00058	4c 89 42 40	 mov	 QWORD PTR [rdx+64], r8
  0005c	c7 82 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7128], 1
  00066	c7 82 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rdx+7132], -1

; 126  : }

  00070	c3		 ret	 0
$LN2@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00071	b8 fe ff ff ff	 mov	 eax, -2

; 126  : }

  00076	c3		 ret	 0
inflateResetKeep ENDP
PUBLIC	inflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN10
	DD	imagerel $LN10+128
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSetDictionary DD imagerel $LN10+128
	DD	imagerel $LN10+188
	DD	imagerel $chain$1$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateSetDictionary DD imagerel $LN10+188
	DD	imagerel $LN10+238
	DD	imagerel $chain$2$inflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateSetDictionary DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+128
	DD	imagerel $unwind$inflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSetDictionary DD 040d21H
	DD	09740dH
	DD	083405H
	DD	imagerel $LN10
	DD	imagerel $LN10+128
	DD	imagerel $unwind$inflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 060e01H
	DD	0a540eH
	DD	0d00a320eH
	DD	06006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateSetDictionary PROC				; COMDAT

; 1271 : {

$LN10:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	45 8b e0	 mov	 r12d, r8d
  00011	4c 8b ea	 mov	 r13, rdx
  00014	48 8b e9	 mov	 rbp, rcx

; 1272 :     struct inflate_state FAR *state;
; 1273 :     unsigned long dictid;
; 1274 :     unsigned char *next;
; 1275 :     unsigned avail;
; 1276 :     int ret;
; 1277 : 
; 1278 :     /* check state */
; 1279 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00017	48 85 c9	 test	 rcx, rcx
  0001a	74 14		 je	 SHORT $LN5@inflateSet
  0001c	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]
  00020	48 85 f6	 test	 rsi, rsi
  00023	74 0b		 je	 SHORT $LN5@inflateSet

; 1280 :     state = (struct inflate_state FAR *)strm->state;
; 1281 :     if (state->wrap != 0 && state->mode != DICT)

  00025	83 7e 08 00	 cmp	 DWORD PTR [rsi+8], 0
  00029	74 19		 je	 SHORT $LN4@inflateSet
  0002b	83 3e 0a	 cmp	 DWORD PTR [rsi], 10
  0002e	74 19		 je	 SHORT $LN9@inflateSet
$LN5@inflateSet:

; 1272 :     struct inflate_state FAR *state;
; 1273 :     unsigned long dictid;
; 1274 :     unsigned char *next;
; 1275 :     unsigned avail;
; 1276 :     int ret;
; 1277 : 
; 1278 :     /* check state */
; 1279 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00030	b8 fe ff ff ff	 mov	 eax, -2

; 1304 :     }
; 1305 :     state->havedict = 1;
; 1306 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1307 :     return Z_OK;
; 1308 : }

  00035	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	41 5d		 pop	 r13
  00040	41 5c		 pop	 r12
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN4@inflateSet:

; 1282 :         return Z_STREAM_ERROR;
; 1283 : 
; 1284 :     /* check for correct dictionary identifier */
; 1285 :     if (state->mode == DICT) {

  00044	83 3e 0a	 cmp	 DWORD PTR [rsi], 10
  00047	75 32		 jne	 SHORT $LN2@inflateSet
$LN9@inflateSet:

; 1286 :         dictid = adler32(0L, Z_NULL, 0);

  00049	45 33 c0	 xor	 r8d, r8d
  0004c	33 d2		 xor	 edx, edx
  0004e	33 c9		 xor	 ecx, ecx
  00050	e8 00 00 00 00	 call	 adler32

; 1287 :         dictid = adler32(dictid, dictionary, dictLength);

  00055	45 8b c4	 mov	 r8d, r12d
  00058	49 8b d5	 mov	 rdx, r13
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 adler32

; 1288 :         if (dictid != state->check)

  00062	3b 46 18	 cmp	 eax, DWORD PTR [rsi+24]
  00065	74 14		 je	 SHORT $LN2@inflateSet

; 1289 :             return Z_DATA_ERROR;

  00067	b8 fd ff ff ff	 mov	 eax, -3

; 1304 :     }
; 1305 :     state->havedict = 1;
; 1306 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1307 :     return Z_OK;
; 1308 : }

  0006c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	41 5d		 pop	 r13
  00077	41 5c		 pop	 r12
  00079	5e		 pop	 rsi
  0007a	c3		 ret	 0
$LN2@inflateSet:

; 1290 :     }
; 1291 : 
; 1292 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1293 :        existing dictionary if appropriate */
; 1294 :     next = strm->next_out;
; 1295 :     avail = strm->avail_out;
; 1296 :     strm->next_out = (Bytef *)dictionary + dictLength;

  0007b	4b 8d 44 25 00	 lea	 rax, QWORD PTR [r13+r12]
  00080	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00085	8b 5d 18	 mov	 ebx, DWORD PTR [rbp+24]
  00088	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0008d	48 8b 7d 10	 mov	 rdi, QWORD PTR [rbp+16]

; 1297 :     strm->avail_out = 0;
; 1298 :     ret = updatewindow(strm, dictLength);

  00091	41 8b d4	 mov	 edx, r12d
  00094	48 8b cd	 mov	 rcx, rbp
  00097	48 89 45 10	 mov	 QWORD PTR [rbp+16], rax
  0009b	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [rbp+24], 0
  000a2	e8 00 00 00 00	 call	 updatewindow

; 1299 :     strm->avail_out = avail;

  000a7	89 5d 18	 mov	 DWORD PTR [rbp+24], ebx
  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1300 :     strm->next_out = next;

  000af	48 89 7d 10	 mov	 QWORD PTR [rbp+16], rdi
  000b3	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1301 :     if (ret) {

  000b8	85 c0		 test	 eax, eax
  000ba	74 1a		 je	 SHORT $LN1@inflateSet

; 1302 :         state->mode = MEM;

  000bc	c7 06 1e 00 00
	00		 mov	 DWORD PTR [rsi], 30

; 1303 :         return Z_MEM_ERROR;

  000c2	b8 fc ff ff ff	 mov	 eax, -4

; 1304 :     }
; 1305 :     state->havedict = 1;
; 1306 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1307 :     return Z_OK;
; 1308 : }

  000c7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	41 5d		 pop	 r13
  000d2	41 5c		 pop	 r12
  000d4	5e		 pop	 rsi
  000d5	c3		 ret	 0
$LN1@inflateSet:
  000d6	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000db	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [rsi+12], 1
  000e2	33 c0		 xor	 eax, eax
  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	41 5d		 pop	 r13
  000ea	41 5c		 pop	 r12
  000ec	5e		 pop	 rsi
  000ed	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	inflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN809
	DD	imagerel $LN809+78
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate DD imagerel $LN809+78
	DD	imagerel $LN809+2292
	DD	imagerel $chain$4$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflate DD imagerel $LN809+2292
	DD	imagerel $LN809+5660
	DD	imagerel $chain$6$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflate DD imagerel $LN809+5660
	DD	imagerel $LN809+5680
	DD	imagerel $chain$7$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflate DD imagerel $LN809+5680
	DD	imagerel $LN809+5804
	DD	imagerel $chain$8$inflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflate DD 0a0021H
	DD	0bf400H
	DD	0cd400H
	DD	0dc400H
	DD	0e7400H
	DD	0f6400H
	DD	imagerel $LN809
	DD	imagerel $LN809+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflate DD 021H
	DD	imagerel $LN809
	DD	imagerel $LN809+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflate DD 0a0021H
	DD	0bf400H
	DD	0cd400H
	DD	0dc400H
	DD	0e7400H
	DD	0f6400H
	DD	imagerel $LN809
	DD	imagerel $LN809+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate DD 0a2c21H
	DD	0bf42cH
	DD	0cd41bH
	DD	0dc413H
	DD	0e740aH
	DD	0f6405H
	DD	imagerel $LN809
	DD	imagerel $LN809+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 041701H
	DD	0e00df217H
	DD	0500a300bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
out$1$ = 52
last$ = 56
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 607  : {

$LN809:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	53		 push	 rbx
  0000b	41 56		 push	 r14
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8b d9	 mov	 rbx, rcx

; 608  :     struct inflate_state FAR *state;
; 609  :     unsigned char FAR *next;    /* next input */
; 610  :     unsigned char FAR *put;     /* next output */
; 611  :     unsigned have, left;        /* available input and output */
; 612  :     unsigned long hold;         /* bit buffer */
; 613  :     unsigned bits;              /* bits in bit buffer */
; 614  :     unsigned in, out;           /* save starting available input and output */
; 615  :     unsigned copy;              /* number of stored or match bytes to copy */
; 616  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 617  :     code here;                  /* current decoding table entry */
; 618  :     code last;                  /* parent table entry */
; 619  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 620  :     int ret;                    /* return code */
; 621  : #ifdef GUNZIP
; 622  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 623  : #endif
; 624  :     static const unsigned short order[19] = /* permutation of code lengths */
; 625  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 626  : 
; 627  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 628  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 f9 15 00
	00		 je	 $LN498@inflate
  00023	4c 8b 71 28	 mov	 r14, QWORD PTR [rcx+40]
  00027	4d 85 f6	 test	 r14, r14
  0002a	0f 84 ec 15 00
	00		 je	 $LN498@inflate
  00030	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00035	0f 84 e1 15 00
	00		 je	 $LN498@inflate
  0003b	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003f	75 0a		 jne	 SHORT $LN499@inflate
  00041	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00045	0f 85 d1 15 00
	00		 jne	 $LN498@inflate
$LN499@inflate:

; 630  : 
; 631  :     state = (struct inflate_state FAR *)strm->state;
; 632  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  0004b	41 8b 06	 mov	 eax, DWORD PTR [r14]
  0004e	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00053	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 633  :     LOAD();

  00058	41 8b 7e 44	 mov	 edi, DWORD PTR [r14+68]
  0005c	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00061	83 f8 0b	 cmp	 eax, 11
  00064	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00069	45 8b 6e 40	 mov	 r13d, DWORD PTR [r14+64]
  0006d	b9 0c 00 00 00	 mov	 ecx, 12
  00072	0f 44 c1	 cmove	 eax, ecx
  00075	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15

; 634  :     in = have;
; 635  :     out = left;
; 636  :     ret = Z_OK;

  0007a	45 33 ff	 xor	 r15d, r15d
  0007d	41 89 06	 mov	 DWORD PTR [r14], eax
  00080	44 8b 53 18	 mov	 r10d, DWORD PTR [rbx+24]
  00084	4c 8b 4b 10	 mov	 r9, QWORD PTR [rbx+16]
  00088	8b 73 08	 mov	 esi, DWORD PTR [rbx+8]
  0008b	4c 8b 23	 mov	 r12, QWORD PTR [rbx]
  0008e	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00092	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00096	89 75 bc	 mov	 DWORD PTR in$1$[rbp-128], esi
  00099	45 8b c2	 mov	 r8d, r10d
  0009c	44 89 55 b4	 mov	 DWORD PTR out$1$[rbp-128], r10d
  000a0	44 89 7d 30	 mov	 DWORD PTR ret$1$[rbp-128], r15d

; 637  :     for (;;)
; 638  :         switch (state->mode) {

  000a4	83 f8 1e	 cmp	 eax, 30
  000a7	0f 87 65 15 00
	00		 ja	 $LN12@inflate
$LN806@inflate:
  000ad	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000b4	48 98		 cdqe
  000b6	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN671@inflate[r11+rax*4]
  000be	49 03 cb	 add	 rcx, r11
  000c1	ff e1		 jmp	 rcx
$LN489@inflate:

; 639  :         case HEAD:
; 640  :             if (state->wrap == 0) {

  000c3	41 8b 56 08	 mov	 edx, DWORD PTR [r14+8]
  000c7	85 d2		 test	 edx, edx
  000c9	75 0c		 jne	 SHORT $LN487@inflate

; 641  :                 state->mode = TYPEDO;

  000cb	41 c7 06 0c 00
	00 00		 mov	 DWORD PTR [r14], 12

; 642  :                 break;

  000d2	e9 08 06 00 00	 jmp	 $LN490@inflate
$LN487@inflate:

; 643  :             }
; 644  :             NEEDBITS(16);

  000d7	83 ff 10	 cmp	 edi, 16
  000da	73 25		 jae	 SHORT $LN486@inflate
  000dc	0f 1f 40 00	 npad	 4
$LL484@inflate:
  000e0	85 f6		 test	 esi, esi
  000e2	0f 84 75 07 00
	00		 je	 $LN765@inflate
  000e8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  000ed	8b cf		 mov	 ecx, edi
  000ef	83 c7 08	 add	 edi, 8
  000f2	d3 e0		 shl	 eax, cl
  000f4	ff ce		 dec	 esi
  000f6	49 ff c4	 inc	 r12
  000f9	44 03 e8	 add	 r13d, eax
  000fc	83 ff 10	 cmp	 edi, 16
  000ff	72 df		 jb	 SHORT $LL484@inflate
$LN486@inflate:

; 645  : #ifdef GUNZIP
; 646  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00101	f6 c2 02	 test	 dl, 2
  00104	74 45		 je	 SHORT $LN478@inflate
  00106	41 81 fd 1f 8b
	00 00		 cmp	 r13d, 35615		; 00008b1fH
  0010d	75 3c		 jne	 SHORT $LN478@inflate

; 647  :                 state->check = crc32(0L, Z_NULL, 0);

  0010f	45 33 c0	 xor	 r8d, r8d
  00112	33 d2		 xor	 edx, edx
  00114	33 c9		 xor	 ecx, ecx
  00116	e8 00 00 00 00	 call	 crc32

; 648  :                 CRC2(state->check, hold);

  0011b	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  0011f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00125	8b c8		 mov	 ecx, eax
  00127	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  0012b	66 44 89 6d b0	 mov	 WORD PTR hbuf$[rbp-128], r13w
  00130	e8 00 00 00 00	 call	 crc32

; 649  :                 INITBITS();

  00135	45 8b ef	 mov	 r13d, r15d
  00138	41 8b ff	 mov	 edi, r15d
  0013b	41 89 46 18	 mov	 DWORD PTR [r14+24], eax

; 650  :                 state->mode = FLAGS;

  0013f	41 c7 06 01 00
	00 00		 mov	 DWORD PTR [r14], 1

; 651  :                 break;

  00146	e9 8c 05 00 00	 jmp	 $LN803@inflate
$LN478@inflate:

; 652  :             }
; 653  :             state->flags = 0;           /* expect zlib header */
; 654  :             if (state->head != Z_NULL)

  0014b	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0014f	45 89 7e 10	 mov	 DWORD PTR [r14+16], r15d
  00153	48 85 c0	 test	 rax, rax
  00156	74 07		 je	 SHORT $LN471@inflate

; 655  :                 state->head->done = -1;

  00158	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN471@inflate:

; 656  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 657  : #else
; 658  :             if (
; 659  : #endif
; 660  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  0015f	41 f6 46 08 01	 test	 BYTE PTR [r14+8], 1
  00164	0f 84 be 00 00
	00		 je	 $LN469@inflate
  0016a	41 0f b6 cd	 movzx	 ecx, r13b
  0016e	41 8b c5	 mov	 eax, r13d
  00171	c1 e8 08	 shr	 eax, 8
  00174	c1 e1 08	 shl	 ecx, 8
  00177	03 c8		 add	 ecx, eax
  00179	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0017e	f7 e1		 mul	 ecx
  00180	8b c1		 mov	 eax, ecx
  00182	2b c2		 sub	 eax, edx
  00184	d1 e8		 shr	 eax, 1
  00186	03 c2		 add	 eax, edx
  00188	c1 e8 04	 shr	 eax, 4
  0018b	6b c0 1f	 imul	 eax, 31
  0018e	3b c8		 cmp	 ecx, eax
  00190	0f 85 92 00 00
	00		 jne	 $LN469@inflate

; 664  :             }
; 665  :             if (BITS(4) != Z_DEFLATED) {

  00196	41 8b c5	 mov	 eax, r13d
  00199	24 0f		 and	 al, 15
  0019b	3c 08		 cmp	 al, 8
  0019d	74 17		 je	 SHORT $LN467@inflate
$LN804@inflate:

; 666  :                 strm->msg = (char *)"unknown compression method";

  0019f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  001a6	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 667  :                 state->mode = BAD;

  001aa	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 668  :                 break;

  001b1	e9 29 05 00 00	 jmp	 $LN490@inflate
$LN467@inflate:

; 669  :             }
; 670  :             DROPBITS(4);
; 671  :             len = BITS(4) + 8;
; 672  :             if (state->wbits == 0)

  001b6	41 8b 46 28	 mov	 eax, DWORD PTR [r14+40]
  001ba	41 c1 ed 04	 shr	 r13d, 4
  001be	83 c7 fc	 add	 edi, -4			; fffffffcH
  001c1	41 8b cd	 mov	 ecx, r13d
  001c4	83 e1 0f	 and	 ecx, 15
  001c7	83 c1 08	 add	 ecx, 8
  001ca	85 c0		 test	 eax, eax
  001cc	75 3f		 jne	 SHORT $LN464@inflate

; 673  :                 state->wbits = len;

  001ce	41 89 4e 28	 mov	 DWORD PTR [r14+40], ecx
$LN462@inflate:

; 678  :             }
; 679  :             state->dmax = 1U << len;

  001d2	b8 01 00 00 00	 mov	 eax, 1

; 680  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 681  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001d7	45 33 c0	 xor	 r8d, r8d
  001da	33 d2		 xor	 edx, edx
  001dc	d3 e0		 shl	 eax, cl
  001de	33 c9		 xor	 ecx, ecx
  001e0	41 89 46 14	 mov	 DWORD PTR [r14+20], eax
  001e4	e8 00 00 00 00	 call	 adler32

; 682  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001e9	41 c1 ed 08	 shr	 r13d, 8
  001ed	41 f7 d5	 not	 r13d
  001f0	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  001f4	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
  001f7	41 83 e5 02	 and	 r13d, 2

; 683  :             INITBITS();

  001fb	41 8b ff	 mov	 edi, r15d
  001fe	41 83 cd 09	 or	 r13d, 9
  00202	45 89 2e	 mov	 DWORD PTR [r14], r13d
  00205	45 8b ef	 mov	 r13d, r15d

; 684  :             break;

  00208	e9 ca 04 00 00	 jmp	 $LN803@inflate
$LN464@inflate:

; 674  :             else if (len > state->wbits) {

  0020d	3b c8		 cmp	 ecx, eax
  0020f	76 c1		 jbe	 SHORT $LN462@inflate

; 675  :                 strm->msg = (char *)"invalid window size";

  00211	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  00218	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 676  :                 state->mode = BAD;

  0021c	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 677  :                 break;

  00223	e9 b7 04 00 00	 jmp	 $LN490@inflate
$LN469@inflate:

; 661  :                 strm->msg = (char *)"incorrect header check";

  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  0022f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 662  :                 state->mode = BAD;

  00233	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 663  :                 break;

  0023a	e9 a0 04 00 00	 jmp	 $LN490@inflate
$LN457@inflate:

; 685  : #ifdef GUNZIP
; 686  :         case FLAGS:
; 687  :             NEEDBITS(16);

  0023f	83 ff 10	 cmp	 edi, 16
  00242	73 21		 jae	 SHORT $LN456@inflate
$LL454@inflate:
  00244	85 f6		 test	 esi, esi
  00246	0f 84 11 06 00
	00		 je	 $LN765@inflate
  0024c	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00251	8b cf		 mov	 ecx, edi
  00253	83 c7 08	 add	 edi, 8
  00256	d3 e0		 shl	 eax, cl
  00258	ff ce		 dec	 esi
  0025a	49 ff c4	 inc	 r12
  0025d	44 03 e8	 add	 r13d, eax
  00260	83 ff 10	 cmp	 edi, 16
  00263	72 df		 jb	 SHORT $LL454@inflate
$LN456@inflate:

; 688  :             state->flags = (int)(hold);

  00265	45 89 6e 10	 mov	 DWORD PTR [r14+16], r13d

; 689  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00269	41 80 fd 08	 cmp	 r13b, 8

; 690  :                 strm->msg = (char *)"unknown compression method";
; 691  :                 state->mode = BAD;
; 692  :                 break;

  0026d	0f 85 2c ff ff
	ff		 jne	 $LN804@inflate

; 693  :             }
; 694  :             if (state->flags & 0xe000) {

  00273	41 f7 c5 00 e0
	00 00		 test	 r13d, 57344		; 0000e000H
  0027a	74 17		 je	 SHORT $LN447@inflate

; 695  :                 strm->msg = (char *)"unknown header flags set";

  0027c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  00283	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00287	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  0028e	e9 4c 04 00 00	 jmp	 $LN490@inflate
$LN447@inflate:

; 696  :                 state->mode = BAD;
; 697  :                 break;
; 698  :             }
; 699  :             if (state->head != Z_NULL)

  00293	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00297	48 85 c9	 test	 rcx, rcx
  0029a	74 0b		 je	 SHORT $LN446@inflate

; 700  :                 state->head->text = (int)((hold >> 8) & 1);

  0029c	41 8b c5	 mov	 eax, r13d
  0029f	c1 e8 08	 shr	 eax, 8
  002a2	83 e0 01	 and	 eax, 1
  002a5	89 01		 mov	 DWORD PTR [rcx], eax
$LN446@inflate:

; 701  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  002a7	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  002af	74 23		 je	 SHORT $LN442@inflate
  002b1	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  002b5	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  002b9	41 c1 ed 08	 shr	 r13d, 8
  002bd	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  002c1	41 b8 02 00 00
	00		 mov	 r8d, 2
  002c7	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  002cb	e8 00 00 00 00	 call	 crc32
  002d0	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN442@inflate:

; 702  :             INITBITS();

  002d4	45 8b ef	 mov	 r13d, r15d
  002d7	41 8b ff	 mov	 edi, r15d

; 703  :             state->mode = TIME;

  002da	41 c7 06 02 00
	00 00		 mov	 DWORD PTR [r14], 2

; 704  :         case TIME:
; 705  :             NEEDBITS(32);

  002e1	eb 05		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  002e3	83 ff 20	 cmp	 edi, 32			; 00000020H
  002e6	73 21		 jae	 SHORT $LN436@inflate
$LL434@inflate:
  002e8	85 f6		 test	 esi, esi
  002ea	0f 84 6d 05 00
	00		 je	 $LN765@inflate
  002f0	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  002f5	8b cf		 mov	 ecx, edi
  002f7	83 c7 08	 add	 edi, 8
  002fa	d3 e0		 shl	 eax, cl
  002fc	ff ce		 dec	 esi
  002fe	49 ff c4	 inc	 r12
  00301	44 03 e8	 add	 r13d, eax
  00304	83 ff 20	 cmp	 edi, 32			; 00000020H
  00307	72 df		 jb	 SHORT $LL434@inflate
$LN436@inflate:

; 706  :             if (state->head != Z_NULL)

  00309	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0030d	48 85 c0	 test	 rax, rax
  00310	74 04		 je	 SHORT $LN428@inflate

; 707  :                 state->head->time = hold;

  00312	44 89 68 04	 mov	 DWORD PTR [rax+4], r13d
$LN428@inflate:

; 708  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  00316	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  0031e	74 35		 je	 SHORT $LN424@inflate
  00320	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00324	41 8b c5	 mov	 eax, r13d
  00327	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  0032b	c1 e8 08	 shr	 eax, 8
  0032e	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00332	41 b8 04 00 00
	00		 mov	 r8d, 4
  00338	88 45 b1	 mov	 BYTE PTR hbuf$[rbp-127], al
  0033b	41 8b c5	 mov	 eax, r13d
  0033e	41 c1 ed 18	 shr	 r13d, 24
  00342	c1 e8 10	 shr	 eax, 16
  00345	44 88 6d b3	 mov	 BYTE PTR hbuf$[rbp-125], r13b
  00349	88 45 b2	 mov	 BYTE PTR hbuf$[rbp-126], al
  0034c	e8 00 00 00 00	 call	 crc32
  00351	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN424@inflate:

; 709  :             INITBITS();

  00355	45 8b ef	 mov	 r13d, r15d
  00358	41 8b ff	 mov	 edi, r15d

; 710  :             state->mode = OS;

  0035b	41 c7 06 03 00
	00 00		 mov	 DWORD PTR [r14], 3

; 711  :         case OS:
; 712  :             NEEDBITS(16);

  00362	eb 0c		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  00364	83 ff 10	 cmp	 edi, 16
  00367	73 28		 jae	 SHORT $LN418@inflate
  00369	0f 1f 80 00 00
	00 00		 npad	 7
$LL416@inflate:
  00370	85 f6		 test	 esi, esi
  00372	0f 84 e5 04 00
	00		 je	 $LN765@inflate
  00378	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0037d	8b cf		 mov	 ecx, edi
  0037f	83 c7 08	 add	 edi, 8
  00382	d3 e0		 shl	 eax, cl
  00384	ff ce		 dec	 esi
  00386	49 ff c4	 inc	 r12
  00389	44 03 e8	 add	 r13d, eax
  0038c	83 ff 10	 cmp	 edi, 16
  0038f	72 df		 jb	 SHORT $LL416@inflate
$LN418@inflate:

; 713  :             if (state->head != Z_NULL) {

  00391	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00395	48 85 c9	 test	 rcx, rcx
  00398	74 14		 je	 SHORT $LN410@inflate

; 714  :                 state->head->xflags = (int)(hold & 0xff);

  0039a	41 0f b6 c5	 movzx	 eax, r13b
  0039e	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 715  :                 state->head->os = (int)(hold >> 8);

  003a1	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  003a5	41 8b cd	 mov	 ecx, r13d
  003a8	c1 e9 08	 shr	 ecx, 8
  003ab	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN410@inflate:

; 716  :             }
; 717  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  003ae	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  003b6	74 23		 je	 SHORT $LN406@inflate
  003b8	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  003bc	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  003c0	41 c1 ed 08	 shr	 r13d, 8
  003c4	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  003c8	41 b8 02 00 00
	00		 mov	 r8d, 2
  003ce	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  003d2	e8 00 00 00 00	 call	 crc32
  003d7	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN406@inflate:

; 718  :             INITBITS();

  003db	45 8b ef	 mov	 r13d, r15d
  003de	41 8b ff	 mov	 edi, r15d

; 719  :             state->mode = EXLEN;

  003e1	41 c7 06 04 00
	00 00		 mov	 DWORD PTR [r14], 4
$LN402@inflate:

; 720  :         case EXLEN:
; 721  :             if (state->flags & 0x0400) {

  003e8	41 f7 46 10 00
	04 00 00	 test	 DWORD PTR [r14+16], 1024 ; 00000400H
  003f0	74 6c		 je	 SHORT $LN401@inflate

; 722  :                 NEEDBITS(16);

  003f2	83 ff 10	 cmp	 edi, 16
  003f5	73 21		 jae	 SHORT $LN399@inflate
$LL397@inflate:
  003f7	85 f6		 test	 esi, esi
  003f9	0f 84 5e 04 00
	00		 je	 $LN765@inflate
  003ff	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00404	8b cf		 mov	 ecx, edi
  00406	83 c7 08	 add	 edi, 8
  00409	d3 e0		 shl	 eax, cl
  0040b	ff ce		 dec	 esi
  0040d	49 ff c4	 inc	 r12
  00410	44 03 e8	 add	 r13d, eax
  00413	83 ff 10	 cmp	 edi, 16
  00416	72 df		 jb	 SHORT $LL397@inflate
$LN399@inflate:

; 723  :                 state->length = (unsigned)(hold);
; 724  :                 if (state->head != Z_NULL)

  00418	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0041c	45 89 6e 48	 mov	 DWORD PTR [r14+72], r13d
  00420	48 85 c0	 test	 rax, rax
  00423	74 04		 je	 SHORT $LN391@inflate

; 725  :                     state->head->extra_len = (unsigned)hold;

  00425	44 89 68 18	 mov	 DWORD PTR [rax+24], r13d
$LN391@inflate:

; 726  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00429	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  00431	74 23		 je	 SHORT $LN387@inflate
  00433	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00437	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  0043b	41 c1 ed 08	 shr	 r13d, 8
  0043f	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00443	41 b8 02 00 00
	00		 mov	 r8d, 2
  00449	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  0044d	e8 00 00 00 00	 call	 crc32
  00452	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN387@inflate:

; 727  :                 INITBITS();

  00456	45 8b ef	 mov	 r13d, r15d
  00459	41 8b ff	 mov	 edi, r15d

; 728  :             }
; 729  :             else if (state->head != Z_NULL)

  0045c	eb 0d		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  0045e	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00462	48 85 c0	 test	 rax, rax
  00465	74 04		 je	 SHORT $LN382@inflate

; 730  :                 state->head->extra = Z_NULL;

  00467	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN382@inflate:

; 731  :             state->mode = EXTRA;

  0046b	41 c7 06 05 00
	00 00		 mov	 DWORD PTR [r14], 5
$LN381@inflate:

; 732  :         case EXTRA:
; 733  :             if (state->flags & 0x0400) {

  00472	41 f7 46 10 00
	04 00 00	 test	 DWORD PTR [r14+16], 1024 ; 00000400H
  0047a	74 79		 je	 SHORT $LN375@inflate

; 734  :                 copy = state->length;

  0047c	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]

; 735  :                 if (copy > have) copy = have;

  00480	3b ce		 cmp	 ecx, esi
  00482	8b d9		 mov	 ebx, ecx
  00484	0f 47 de	 cmova	 ebx, esi

; 736  :                 if (copy) {

  00487	85 db		 test	 ebx, ebx
  00489	74 5f		 je	 SHORT $LN378@inflate

; 737  :                     if (state->head != Z_NULL &&
; 738  :                         state->head->extra != Z_NULL) {

  0048b	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0048f	48 85 c0	 test	 rax, rax
  00492	74 2e		 je	 SHORT $LN377@inflate
  00494	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  00498	4d 85 c9	 test	 r9, r9
  0049b	74 25		 je	 SHORT $LN377@inflate

; 739  :                         len = state->head->extra_len - state->length;

  0049d	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  004a0	2b d1		 sub	 edx, ecx

; 740  :                         zmemcpy(state->head->extra + len, next,
; 741  :                                 len + copy > state->head->extra_max ?
; 742  :                                 state->head->extra_max - len : copy);

  004a2	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004a5	8d 04 13	 lea	 eax, DWORD PTR [rbx+rdx]
  004a8	3b c1		 cmp	 eax, ecx
  004aa	76 04		 jbe	 SHORT $LN502@inflate
  004ac	2b ca		 sub	 ecx, edx
  004ae	eb 02		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  004b0	8b cb		 mov	 ecx, ebx
$LN503@inflate:
  004b2	44 8b c1	 mov	 r8d, ecx
  004b5	8b ca		 mov	 ecx, edx
  004b7	49 8b d4	 mov	 rdx, r12
  004ba	49 03 c9	 add	 rcx, r9
  004bd	e8 00 00 00 00	 call	 memcpy
$LN377@inflate:

; 743  :                     }
; 744  :                     if (state->flags & 0x0200)

  004c2	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  004ca	74 13		 je	 SHORT $LN376@inflate

; 745  :                         state->check = crc32(state->check, next, copy);

  004cc	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  004d0	44 8b c3	 mov	 r8d, ebx
  004d3	49 8b d4	 mov	 rdx, r12
  004d6	e8 00 00 00 00	 call	 crc32
  004db	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN376@inflate:

; 746  :                     have -= copy;
; 747  :                     next += copy;

  004df	8b c3		 mov	 eax, ebx
  004e1	2b f3		 sub	 esi, ebx
  004e3	4c 03 e0	 add	 r12, rax

; 748  :                     state->length -= copy;

  004e6	41 29 5e 48	 sub	 DWORD PTR [r14+72], ebx
$LN378@inflate:

; 749  :                 }
; 750  :                 if (state->length) goto inf_leave;

  004ea	41 83 7e 48 00	 cmp	 DWORD PTR [r14+72], 0
  004ef	0f 85 68 03 00
	00		 jne	 $LN765@inflate
$LN375@inflate:

; 751  :             }
; 752  :             state->length = 0;

  004f5	45 89 7e 48	 mov	 DWORD PTR [r14+72], r15d

; 753  :             state->mode = NAME;

  004f9	41 c7 06 06 00
	00 00		 mov	 DWORD PTR [r14], 6
$LN374@inflate:

; 754  :         case NAME:
; 755  :             if (state->flags & 0x0800) {

  00500	41 f7 46 10 00
	08 00 00	 test	 DWORD PTR [r14+16], 2048 ; 00000800H
  00508	74 7e		 je	 SHORT $LN373@inflate

; 756  :                 if (have == 0) goto inf_leave;

  0050a	85 f6		 test	 esi, esi
  0050c	0f 84 4b 03 00
	00		 je	 $LN765@inflate

; 757  :                 copy = 0;

  00512	4d 8b c4	 mov	 r8, r12
  00515	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL371@inflate:

; 758  :                 do {
; 759  :                     len = (unsigned)(next[copy++]);
; 760  :                     if (state->head != Z_NULL &&
; 761  :                             state->head->name != Z_NULL &&
; 762  :                             state->length < state->head->name_max)

  00520	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00524	41 0f b6 18	 movzx	 ebx, BYTE PTR [r8]
  00528	41 ff c7	 inc	 r15d
  0052b	49 ff c0	 inc	 r8
  0052e	48 85 c0	 test	 rax, rax
  00531	74 19		 je	 SHORT $LN370@inflate
  00533	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00537	48 85 d2	 test	 rdx, rdx
  0053a	74 10		 je	 SHORT $LN370@inflate
  0053c	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]
  00540	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  00543	73 07		 jae	 SHORT $LN370@inflate

; 763  :                         state->head->name[state->length++] = len;

  00545	88 1c 11	 mov	 BYTE PTR [rcx+rdx], bl
  00548	41 ff 46 48	 inc	 DWORD PTR [r14+72]
$LN370@inflate:

; 764  :                 } while (len && copy < have);

  0054c	85 db		 test	 ebx, ebx
  0054e	74 05		 je	 SHORT $LN367@inflate
  00550	44 3b fe	 cmp	 r15d, esi
  00553	72 cb		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 765  :                 if (state->flags & 0x0200)

  00555	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  0055d	74 13		 je	 SHORT $LN366@inflate

; 766  :                     state->check = crc32(state->check, next, copy);

  0055f	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00563	45 8b c7	 mov	 r8d, r15d
  00566	49 8b d4	 mov	 rdx, r12
  00569	e8 00 00 00 00	 call	 crc32
  0056e	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN366@inflate:

; 767  :                 have -= copy;
; 768  :                 next += copy;

  00572	41 8b c7	 mov	 eax, r15d
  00575	41 2b f7	 sub	 esi, r15d
  00578	4c 03 e0	 add	 r12, rax

; 769  :                 if (len) goto inf_leave;

  0057b	85 db		 test	 ebx, ebx
  0057d	0f 85 da 02 00
	00		 jne	 $LN765@inflate

; 770  :             }
; 771  :             else if (state->head != Z_NULL)

  00583	45 33 ff	 xor	 r15d, r15d
  00586	eb 0d		 jmp	 SHORT $LN363@inflate
$LN373@inflate:
  00588	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0058c	48 85 c0	 test	 rax, rax
  0058f	74 04		 je	 SHORT $LN363@inflate

; 772  :                 state->head->name = Z_NULL;

  00591	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN363@inflate:

; 773  :             state->length = 0;

  00595	45 89 7e 48	 mov	 DWORD PTR [r14+72], r15d

; 774  :             state->mode = COMMENT;

  00599	41 c7 06 07 00
	00 00		 mov	 DWORD PTR [r14], 7
$LN362@inflate:

; 775  :         case COMMENT:
; 776  :             if (state->flags & 0x1000) {

  005a0	41 f7 46 10 00
	10 00 00	 test	 DWORD PTR [r14+16], 4096 ; 00001000H
  005a8	74 7e		 je	 SHORT $LN361@inflate

; 777  :                 if (have == 0) goto inf_leave;

  005aa	85 f6		 test	 esi, esi
  005ac	0f 84 ab 02 00
	00		 je	 $LN765@inflate

; 778  :                 copy = 0;

  005b2	4d 8b c4	 mov	 r8, r12
  005b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL359@inflate:

; 779  :                 do {
; 780  :                     len = (unsigned)(next[copy++]);
; 781  :                     if (state->head != Z_NULL &&
; 782  :                             state->head->comment != Z_NULL &&
; 783  :                             state->length < state->head->comm_max)

  005c0	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  005c4	41 0f b6 18	 movzx	 ebx, BYTE PTR [r8]
  005c8	41 ff c7	 inc	 r15d
  005cb	49 ff c0	 inc	 r8
  005ce	48 85 c0	 test	 rax, rax
  005d1	74 19		 je	 SHORT $LN358@inflate
  005d3	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  005d7	48 85 d2	 test	 rdx, rdx
  005da	74 10		 je	 SHORT $LN358@inflate
  005dc	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]
  005e0	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  005e3	73 07		 jae	 SHORT $LN358@inflate

; 784  :                         state->head->comment[state->length++] = len;

  005e5	88 1c 11	 mov	 BYTE PTR [rcx+rdx], bl
  005e8	41 ff 46 48	 inc	 DWORD PTR [r14+72]
$LN358@inflate:

; 785  :                 } while (len && copy < have);

  005ec	85 db		 test	 ebx, ebx
  005ee	74 05		 je	 SHORT $LN355@inflate
  005f0	44 3b fe	 cmp	 r15d, esi
  005f3	72 cb		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 786  :                 if (state->flags & 0x0200)

  005f5	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  005fd	74 13		 je	 SHORT $LN354@inflate

; 787  :                     state->check = crc32(state->check, next, copy);

  005ff	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00603	45 8b c7	 mov	 r8d, r15d
  00606	49 8b d4	 mov	 rdx, r12
  00609	e8 00 00 00 00	 call	 crc32
  0060e	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN354@inflate:

; 788  :                 have -= copy;
; 789  :                 next += copy;

  00612	41 8b c7	 mov	 eax, r15d
  00615	41 2b f7	 sub	 esi, r15d
  00618	4c 03 e0	 add	 r12, rax

; 790  :                 if (len) goto inf_leave;

  0061b	85 db		 test	 ebx, ebx
  0061d	0f 85 3a 02 00
	00		 jne	 $LN765@inflate

; 791  :             }
; 792  :             else if (state->head != Z_NULL)

  00623	45 33 ff	 xor	 r15d, r15d
  00626	eb 0d		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  00628	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0062c	48 85 c0	 test	 rax, rax
  0062f	74 04		 je	 SHORT $LN351@inflate

; 793  :                 state->head->comment = Z_NULL;

  00631	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN351@inflate:
  00635	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00639	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0063d	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 794  :             state->mode = HCRC;

  00641	41 c7 06 08 00
	00 00		 mov	 DWORD PTR [r14], 8
$LN350@inflate:

; 795  :         case HCRC:
; 796  :             if (state->flags & 0x0200) {

  00648	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  00650	74 4a		 je	 SHORT $LN336@inflate

; 797  :                 NEEDBITS(16);

  00652	83 ff 10	 cmp	 edi, 16
  00655	73 21		 jae	 SHORT $LN347@inflate
$LL345@inflate:
  00657	85 f6		 test	 esi, esi
  00659	0f 84 fe 01 00
	00		 je	 $LN765@inflate
  0065f	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00664	8b cf		 mov	 ecx, edi
  00666	83 c7 08	 add	 edi, 8
  00669	d3 e0		 shl	 eax, cl
  0066b	ff ce		 dec	 esi
  0066d	49 ff c4	 inc	 r12
  00670	44 03 e8	 add	 r13d, eax
  00673	83 ff 10	 cmp	 edi, 16
  00676	72 df		 jb	 SHORT $LL345@inflate
$LN347@inflate:

; 798  :                 if (hold != (state->check & 0xffff)) {

  00678	41 0f b7 46 18	 movzx	 eax, WORD PTR [r14+24]
  0067d	44 3b e8	 cmp	 r13d, eax
  00680	74 14		 je	 SHORT $LN338@inflate

; 799  :                     strm->msg = (char *)"header crc mismatch";

  00682	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00689	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0068d	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00694	eb 49		 jmp	 SHORT $LN490@inflate
$LN338@inflate:

; 800  :                     state->mode = BAD;
; 801  :                     break;
; 802  :                 }
; 803  :                 INITBITS();

  00696	45 8b ef	 mov	 r13d, r15d
  00699	41 8b ff	 mov	 edi, r15d
$LN336@inflate:

; 804  :             }
; 805  :             if (state->head != Z_NULL) {

  0069c	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  006a0	48 85 c9	 test	 rcx, rcx
  006a3	74 18		 je	 SHORT $LN335@inflate

; 806  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006a5	41 8b 46 10	 mov	 eax, DWORD PTR [r14+16]
  006a9	c1 f8 09	 sar	 eax, 9
  006ac	83 e0 01	 and	 eax, 1
  006af	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 807  :                 state->head->done = 1;

  006b2	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  006b6	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN335@inflate:

; 808  :             }
; 809  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006bd	45 33 c0	 xor	 r8d, r8d
  006c0	33 d2		 xor	 edx, edx
  006c2	33 c9		 xor	 ecx, ecx
  006c4	e8 00 00 00 00	 call	 crc32
  006c9	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  006cd	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN808@inflate:

; 1059 :                 state->mode = TYPE;

  006d0	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11
$LN803@inflate:

; 684  :             break;

  006d7	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
$LN730@inflate:

; 953  :                             break;

  006db	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
$LN490@inflate:

; 637  :     for (;;)
; 638  :         switch (state->mode) {

  006df	41 8b 06	 mov	 eax, DWORD PTR [r14]
  006e2	83 f8 1e	 cmp	 eax, 30
  006e5	0f 87 27 0f 00
	00		 ja	 $LN12@inflate
  006eb	44 8b 45 b4	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  006ef	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  006f2	45 33 ff	 xor	 r15d, r15d
  006f5	e9 b3 f9 ff ff	 jmp	 $LN806@inflate
$LN333@inflate:

; 810  :             state->mode = TYPE;
; 811  :             break;
; 812  : #endif
; 813  :         case DICTID:
; 814  :             NEEDBITS(32);

  006fa	83 ff 20	 cmp	 edi, 32			; 00000020H
  006fd	73 22		 jae	 SHORT $LN332@inflate
  006ff	90		 npad	 1
$LL330@inflate:
  00700	85 f6		 test	 esi, esi
  00702	0f 84 55 01 00
	00		 je	 $LN765@inflate
  00708	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0070d	8b cf		 mov	 ecx, edi
  0070f	83 c7 08	 add	 edi, 8
  00712	d3 e0		 shl	 eax, cl
  00714	ff ce		 dec	 esi
  00716	49 ff c4	 inc	 r12
  00719	44 03 e8	 add	 r13d, eax
  0071c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0071f	72 df		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 815  :             strm->adler = state->check = ZSWAP32(hold);

  00721	41 8b cd	 mov	 ecx, r13d
  00724	41 8b c5	 mov	 eax, r13d

; 816  :             INITBITS();

  00727	41 8b ff	 mov	 edi, r15d
  0072a	c1 e0 10	 shl	 eax, 16
  0072d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00733	03 c8		 add	 ecx, eax
  00735	41 8b c5	 mov	 eax, r13d
  00738	41 c1 ed 18	 shr	 r13d, 24
  0073c	c1 e8 08	 shr	 eax, 8
  0073f	c1 e1 08	 shl	 ecx, 8
  00742	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00747	03 c1		 add	 eax, ecx
  00749	41 03 c5	 add	 eax, r13d
  0074c	45 8b ef	 mov	 r13d, r15d
  0074f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  00753	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 817  :             state->mode = DICT;

  00756	41 c7 06 0a 00
	00 00		 mov	 DWORD PTR [r14], 10
$LN321@inflate:

; 818  :         case DICT:
; 819  :             if (state->havedict == 0) {

  0075d	41 83 7e 0c 00	 cmp	 DWORD PTR [r14+12], 0
  00762	0f 84 ad 0d 00
	00		 je	 $LN579@inflate

; 822  :             }
; 823  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00768	45 33 c0	 xor	 r8d, r8d
  0076b	33 d2		 xor	 edx, edx
  0076d	33 c9		 xor	 ecx, ecx
  0076f	e8 00 00 00 00	 call	 adler32
  00774	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00778	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0077c	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  0077f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  00783	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 824  :             state->mode = TYPE;

  00786	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11
$LN316@inflate:

; 825  :         case TYPE:
; 826  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  0078d	83 fa 05	 cmp	 edx, 5
  00790	0f 84 c7 00 00
	00		 je	 $LN765@inflate
  00796	83 fa 06	 cmp	 edx, 6
  00799	0f 84 be 00 00
	00		 je	 $LN765@inflate
$LN315@inflate:

; 827  :         case TYPEDO:
; 828  :             if (state->last) {

  0079f	41 83 7e 04 00	 cmp	 DWORD PTR [r14+4], 0
  007a4	74 16		 je	 SHORT $LN308@inflate

; 829  :                 BYTEBITS();

  007a6	8b cf		 mov	 ecx, edi

; 830  :                 state->mode = CHECK;

  007a8	41 c7 06 1a 00
	00 00		 mov	 DWORD PTR [r14], 26
  007af	83 e1 07	 and	 ecx, 7
  007b2	41 d3 ed	 shr	 r13d, cl
  007b5	2b f9		 sub	 edi, ecx

; 831  :                 break;

  007b7	e9 23 ff ff ff	 jmp	 $LN490@inflate
$LN308@inflate:

; 832  :             }
; 833  :             NEEDBITS(3);

  007bc	83 ff 03	 cmp	 edi, 3
  007bf	73 21		 jae	 SHORT $LN307@inflate
$LL305@inflate:
  007c1	85 f6		 test	 esi, esi
  007c3	0f 84 94 00 00
	00		 je	 $LN765@inflate
  007c9	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  007ce	8b cf		 mov	 ecx, edi
  007d0	83 c7 08	 add	 edi, 8
  007d3	d3 e0		 shl	 eax, cl
  007d5	ff ce		 dec	 esi
  007d7	49 ff c4	 inc	 r12
  007da	44 03 e8	 add	 r13d, eax
  007dd	83 ff 03	 cmp	 edi, 3
  007e0	72 df		 jb	 SHORT $LL305@inflate
$LN307@inflate:

; 834  :             state->last = BITS(1);

  007e2	41 8b c5	 mov	 eax, r13d

; 835  :             DROPBITS(1);

  007e5	41 d1 ed	 shr	 r13d, 1
  007e8	ff cf		 dec	 edi
  007ea	83 e0 01	 and	 eax, 1
  007ed	41 89 46 04	 mov	 DWORD PTR [r14+4], eax

; 836  :             switch (BITS(2)) {

  007f1	41 8b c5	 mov	 eax, r13d
  007f4	83 e0 03	 and	 eax, 3
  007f7	0f 84 f7 00 00
	00		 je	 $LN294@inflate
  007fd	ff c8		 dec	 eax
  007ff	74 3d		 je	 SHORT $LN293@inflate
  00801	ff c8		 dec	 eax
  00803	74 26		 je	 SHORT $LN288@inflate
  00805	ff c8		 dec	 eax
  00807	0f 85 ee 00 00
	00		 jne	 $LN286@inflate

; 849  :                     goto inf_leave;
; 850  :                 }
; 851  :                 break;
; 852  :             case 2:                             /* dynamic block */
; 853  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 854  :                         state->last ? " (last)" : ""));
; 855  :                 state->mode = TABLE;
; 856  :                 break;
; 857  :             case 3:
; 858  :                 strm->msg = (char *)"invalid block type";

  0080d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  00814	41 c1 ed 02	 shr	 r13d, 2
  00818	83 c7 fe	 add	 edi, -2			; fffffffeH
  0081b	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0081f	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 862  :             break;

  00826	e9 b4 fe ff ff	 jmp	 $LN490@inflate
$LN288@inflate:

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  0082b	41 c1 ed 02	 shr	 r13d, 2
  0082f	41 c7 06 10 00
	00 00		 mov	 DWORD PTR [r14], 16
  00836	83 c7 fe	 add	 edi, -2			; fffffffeH

; 862  :             break;

  00839	e9 a1 fe ff ff	 jmp	 $LN490@inflate
$LN293@inflate:

; 841  :                 break;
; 842  :             case 1:                             /* fixed block */
; 843  :                 fixedtables(state);

  0083e	49 8b ce	 mov	 rcx, r14
  00841	e8 00 00 00 00	 call	 fixedtables

; 844  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 845  :                         state->last ? " (last)" : ""));
; 846  :                 state->mode = LEN_;             /* decode codes */

  00846	41 c7 06 13 00
	00 00		 mov	 DWORD PTR [r14], 19

; 847  :                 if (flush == Z_TREES) {

  0084d	83 fa 06	 cmp	 edx, 6
  00850	0f 85 a5 00 00
	00		 jne	 $LN286@inflate

; 848  :                     DROPBITS(2);

  00856	41 c1 ed 02	 shr	 r13d, 2
  0085a	83 c7 fe	 add	 edi, -2			; fffffffeH
$LN765@inflate:

; 1007 :             state->distbits = 6;
; 1008 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1009 :                             &(state->next), &(state->distbits), state->work);

  0085d	44 8b 7d 30	 mov	 r15d, DWORD PTR ret$1$[rbp-128]
$LN807@inflate:
  00861	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
$inf_leave$81100:

; 1221 :         }
; 1222 : 
; 1223 :     /*
; 1224 :        Return from inflate(), updating the total counts and the check value.
; 1225 :        If there was no progress during the inflate() call, return a buffer
; 1226 :        error.  Call updatewindow() to create and/or update the window state.
; 1227 :        Note: a memory error from inflate() is non-recoverable.
; 1228 :      */
; 1229 :   inf_leave:
; 1230 :     RESTORE();

  00864	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00868	48 8b 45 c0	 mov	 rax, QWORD PTR put$1$[rbp-128]
  0086c	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00870	8b 45 38	 mov	 eax, DWORD PTR left$1$[rbp-128]
  00873	4c 89 23	 mov	 QWORD PTR [rbx], r12
  00876	89 43 18	 mov	 DWORD PTR [rbx+24], eax
  00879	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 1231 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1232 :             (state->mode < CHECK || flush != Z_FINISH)))

  0087c	41 83 7e 2c 00	 cmp	 DWORD PTR [r14+44], 0
  00881	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  00885	8b 7d b4	 mov	 edi, DWORD PTR out$1$[rbp-128]
  00888	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  0088c	75 23		 jne	 SHORT $LN6@inflate
  0088e	3b 7b 18	 cmp	 edi, DWORD PTR [rbx+24]
  00891	0f 84 c1 0c 00
	00		 je	 $LN5@inflate
  00897	41 8b 06	 mov	 eax, DWORD PTR [r14]
  0089a	83 f8 1d	 cmp	 eax, 29
  0089d	0f 8d b5 0c 00
	00		 jge	 $LN5@inflate
  008a3	83 f8 1a	 cmp	 eax, 26
  008a6	7c 09		 jl	 SHORT $LN6@inflate
  008a8	83 f9 04	 cmp	 ecx, 4
  008ab	0f 84 a7 0c 00
	00		 je	 $LN5@inflate
$LN6@inflate:

; 1233 :         if (updatewindow(strm, out)) {

  008b1	8b d7		 mov	 edx, edi
  008b3	48 8b cb	 mov	 rcx, rbx
  008b6	e8 00 00 00 00	 call	 updatewindow
  008bb	85 c0		 test	 eax, eax
  008bd	0f 84 95 0c 00
	00		 je	 $LN5@inflate

; 1234 :             state->mode = MEM;

  008c3	41 c7 06 1e 00
	00 00		 mov	 DWORD PTR [r14], 30
$LN13@inflate:

; 1235 :             return Z_MEM_ERROR;

  008ca	b8 fc ff ff ff	 mov	 eax, -4
$LN798@inflate:
  008cf	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  008d4	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  008d9	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  008de	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  008e3	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1251 : }

  008e8	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  008ef	41 5e		 pop	 r14
  008f1	5b		 pop	 rbx
  008f2	5d		 pop	 rbp
  008f3	c3		 ret	 0
$LN294@inflate:

; 837  :             case 0:                             /* stored block */
; 838  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = STORED;

  008f4	41 c7 06 0d 00
	00 00		 mov	 DWORD PTR [r14], 13
$LN286@inflate:

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  008fb	41 c1 ed 02	 shr	 r13d, 2
  008ff	83 c7 fe	 add	 edi, -2			; fffffffeH

; 862  :             break;

  00902	e9 d8 fd ff ff	 jmp	 $LN490@inflate
$LN282@inflate:

; 863  :         case STORED:
; 864  :             BYTEBITS();                         /* go to byte boundary */

  00907	8b cf		 mov	 ecx, edi
  00909	83 e1 07	 and	 ecx, 7
  0090c	2b f9		 sub	 edi, ecx
  0090e	41 d3 ed	 shr	 r13d, cl

; 865  :             NEEDBITS(32);

  00911	83 ff 20	 cmp	 edi, 32			; 00000020H
  00914	73 21		 jae	 SHORT $LN278@inflate
$LL276@inflate:
  00916	85 f6		 test	 esi, esi
  00918	0f 84 3f ff ff
	ff		 je	 $LN765@inflate
  0091e	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00923	8b cf		 mov	 ecx, edi
  00925	83 c7 08	 add	 edi, 8
  00928	d3 e0		 shl	 eax, cl
  0092a	ff ce		 dec	 esi
  0092c	49 ff c4	 inc	 r12
  0092f	44 03 e8	 add	 r13d, eax
  00932	83 ff 20	 cmp	 edi, 32			; 00000020H
  00935	72 df		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 866  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00937	41 8b c5	 mov	 eax, r13d
  0093a	41 0f b7 cd	 movzx	 ecx, r13w
  0093e	f7 d0		 not	 eax
  00940	c1 e8 10	 shr	 eax, 16
  00943	3b c8		 cmp	 ecx, eax
  00945	74 17		 je	 SHORT $LN270@inflate

; 867  :                 strm->msg = (char *)"invalid stored block lengths";

  00947	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0094e	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00952	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00959	e9 81 fd ff ff	 jmp	 $LN490@inflate
$LN270@inflate:

; 868  :                 state->mode = BAD;
; 869  :                 break;
; 870  :             }
; 871  :             state->length = (unsigned)hold & 0xffff;

  0095e	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 872  :             Tracev((stderr, "inflate:       stored length %u\n",
; 873  :                     state->length));
; 874  :             INITBITS();

  00962	45 8b ef	 mov	 r13d, r15d
  00965	41 8b ff	 mov	 edi, r15d

; 875  :             state->mode = COPY_;

  00968	41 c7 06 0e 00
	00 00		 mov	 DWORD PTR [r14], 14

; 876  :             if (flush == Z_TREES) goto inf_leave;

  0096f	83 fa 06	 cmp	 edx, 6
  00972	0f 84 e5 fe ff
	ff		 je	 $LN765@inflate
$LN266@inflate:

; 877  :         case COPY_:
; 878  :             state->mode = COPY;

  00978	41 c7 06 0f 00
	00 00		 mov	 DWORD PTR [r14], 15
$LN264@inflate:

; 879  :         case COPY:
; 880  :             copy = state->length;

  0097f	45 8b 7e 48	 mov	 r15d, DWORD PTR [r14+72]

; 881  :             if (copy) {

  00983	45 85 ff	 test	 r15d, r15d
  00986	74 51		 je	 SHORT $LN263@inflate

; 882  :                 if (copy > have) copy = have;

  00988	44 3b fe	 cmp	 r15d, esi
  0098b	44 0f 47 fe	 cmova	 r15d, esi

; 883  :                 if (copy > left) copy = left;

  0098f	45 3b fa	 cmp	 r15d, r10d
  00992	45 0f 47 fa	 cmova	 r15d, r10d

; 884  :                 if (copy == 0) goto inf_leave;

  00996	45 85 ff	 test	 r15d, r15d
  00999	0f 84 be fe ff
	ff		 je	 $LN765@inflate

; 885  :                 zmemcpy(put, next, copy);

  0099f	45 8b c7	 mov	 r8d, r15d
  009a2	49 8b d4	 mov	 rdx, r12
  009a5	49 8b c9	 mov	 rcx, r9
  009a8	41 8b df	 mov	 ebx, r15d
  009ab	e8 00 00 00 00	 call	 memcpy

; 886  :                 have -= copy;
; 887  :                 next += copy;
; 888  :                 left -= copy;

  009b0	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 889  :                 put += copy;

  009b4	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  009b8	45 2b d7	 sub	 r10d, r15d
  009bb	4c 03 e3	 add	 r12, rbx
  009be	4c 03 cb	 add	 r9, rbx

; 890  :                 state->length -= copy;
; 891  :                 break;

  009c1	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  009c5	41 2b f7	 sub	 esi, r15d
  009c8	45 29 7e 48	 sub	 DWORD PTR [r14+72], r15d
  009cc	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  009d0	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  009d4	e9 06 fd ff ff	 jmp	 $LN490@inflate
$LN263@inflate:

; 892  :             }
; 893  :             Tracev((stderr, "inflate:       stored end\n"));
; 894  :             state->mode = TYPE;

  009d9	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11

; 895  :             break;

  009e0	e9 fa fc ff ff	 jmp	 $LN490@inflate
$LN258@inflate:

; 896  :         case TABLE:
; 897  :             NEEDBITS(14);

  009e5	83 ff 0e	 cmp	 edi, 14
  009e8	73 27		 jae	 SHORT $LN257@inflate
  009ea	66 0f 1f 44 00
	00		 npad	 6
$LL255@inflate:
  009f0	85 f6		 test	 esi, esi
  009f2	0f 84 65 fe ff
	ff		 je	 $LN765@inflate
  009f8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  009fd	8b cf		 mov	 ecx, edi
  009ff	83 c7 08	 add	 edi, 8
  00a02	d3 e0		 shl	 eax, cl
  00a04	ff ce		 dec	 esi
  00a06	49 ff c4	 inc	 r12
  00a09	44 03 e8	 add	 r13d, eax
  00a0c	83 ff 0e	 cmp	 edi, 14
  00a0f	72 df		 jb	 SHORT $LL255@inflate
$LN257@inflate:

; 898  :             state->nlen = BITS(5) + 257;

  00a11	41 8b cd	 mov	 ecx, r13d

; 899  :             DROPBITS(5);

  00a14	41 c1 ed 05	 shr	 r13d, 5

; 900  :             state->ndist = BITS(5) + 1;
; 901  :             DROPBITS(5);
; 902  :             state->ncode = BITS(4) + 4;
; 903  :             DROPBITS(4);

  00a18	83 c7 f2	 add	 edi, -14		; fffffff2H
  00a1b	41 8b d5	 mov	 edx, r13d
  00a1e	41 c1 ed 05	 shr	 r13d, 5
  00a22	83 e1 1f	 and	 ecx, 31
  00a25	41 8b c5	 mov	 eax, r13d
  00a28	83 e2 1f	 and	 edx, 31
  00a2b	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a31	83 e0 0f	 and	 eax, 15
  00a34	ff c2		 inc	 edx
  00a36	41 c1 ed 04	 shr	 r13d, 4
  00a3a	83 c0 04	 add	 eax, 4
  00a3d	41 89 4e 74	 mov	 DWORD PTR [r14+116], ecx
  00a41	41 89 56 78	 mov	 DWORD PTR [r14+120], edx
  00a45	41 89 46 70	 mov	 DWORD PTR [r14+112], eax

; 904  : #ifndef PKZIP_BUG_WORKAROUND
; 905  :             if (state->nlen > 286 || state->ndist > 30) {

  00a49	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a4f	0f 87 03 01 00
	00		 ja	 $LN239@inflate
  00a55	83 fa 1e	 cmp	 edx, 30
  00a58	0f 87 fa 00 00
	00		 ja	 $LN239@inflate

; 907  :                 state->mode = BAD;
; 908  :                 break;
; 909  :             }
; 910  : #endif
; 911  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 912  :             state->have = 0;

  00a5e	45 89 7e 7c	 mov	 DWORD PTR [r14+124], r15d

; 913  :             state->mode = LENLENS;

  00a62	41 c7 06 11 00
	00 00		 mov	 DWORD PTR [r14], 17
$LN525@inflate:

; 914  :         case LENLENS:
; 915  :             while (state->have < state->ncode) {

  00a69	41 8b 46 70	 mov	 eax, DWORD PTR [r14+112]
  00a6d	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00a71	73 59		 jae	 SHORT $LN527@inflate
$LL237@inflate:

; 916  :                 NEEDBITS(3);

  00a73	83 ff 03	 cmp	 edi, 3
  00a76	73 21		 jae	 SHORT $LN234@inflate
$LL232@inflate:
  00a78	85 f6		 test	 esi, esi
  00a7a	0f 84 dd fd ff
	ff		 je	 $LN765@inflate
  00a80	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00a85	8b cf		 mov	 ecx, edi
  00a87	83 c7 08	 add	 edi, 8
  00a8a	d3 e0		 shl	 eax, cl
  00a8c	ff ce		 dec	 esi
  00a8e	49 ff c4	 inc	 r12
  00a91	44 03 e8	 add	 r13d, eax
  00a94	83 ff 03	 cmp	 edi, 3
  00a97	72 df		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 917  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a99	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00a9d	41 0f b7 cd	 movzx	 ecx, r13w

; 918  :                 DROPBITS(3);

  00aa1	83 c7 fd	 add	 edi, -3			; fffffffdH
  00aa4	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00aad	66 83 e1 07	 and	 cx, 7
  00ab1	41 c1 ed 03	 shr	 r13d, 3
  00ab5	66 41 89 8c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], cx
  00abe	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00ac2	41 8b 46 70	 mov	 eax, DWORD PTR [r14+112]
  00ac6	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00aca	72 a7		 jb	 SHORT $LL237@inflate
$LN527@inflate:

; 919  :             }
; 920  :             while (state->have < 19)

  00acc	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  00ad1	73 21		 jae	 SHORT $LN222@inflate
$LL223@inflate:

; 921  :                 state->lens[order[state->have++]] = 0;

  00ad3	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00ad7	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00ae0	66 45 89 bc 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], r15w
  00ae9	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00aed	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  00af2	72 df		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 922  :             state->next = state->codes;
; 923  :             state->lencode = (code const FAR *)(state->next);
; 924  :             state->lenbits = 7;

  00af4	49 8d 4e 68	 lea	 rcx, QWORD PTR [r14+104]
  00af8	49 8d 86 48 05
	00 00		 lea	 rax, QWORD PTR [r14+1352]
  00aff	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00b06	49 89 01	 mov	 QWORD PTR [r9], rax
  00b09	49 89 46 58	 mov	 QWORD PTR [r14+88], rax

; 925  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 926  :                                 &(state->lenbits), state->work);

  00b0d	49 8d 86 08 03
	00 00		 lea	 rax, QWORD PTR [r14+776]
  00b14	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b19	c7 01 07 00 00
	00		 mov	 DWORD PTR [rcx], 7
  00b1f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b24	33 c9		 xor	 ecx, ecx
  00b26	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00b2d	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00b31	e8 00 00 00 00	 call	 inflate_table

; 930  :                 break;

  00b36	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  00b3a	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax
  00b3d	85 c0		 test	 eax, eax
  00b3f	74 2e		 je	 SHORT $LN221@inflate

; 927  :             if (ret) {
; 928  :                 strm->msg = (char *)"invalid code lengths set";

  00b41	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  00b48	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 929  :                 state->mode = BAD;

  00b4c	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 930  :                 break;

  00b53	e9 83 fb ff ff	 jmp	 $LN730@inflate
$LN239@inflate:

; 906  :                 strm->msg = (char *)"too many length or distance symbols";

  00b58	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b5f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00b63	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00b6a	e9 70 fb ff ff	 jmp	 $LN490@inflate
$LN221@inflate:

; 931  :             }
; 932  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 933  :             state->have = 0;

  00b6f	45 89 7e 7c	 mov	 DWORD PTR [r14+124], r15d

; 934  :             state->mode = CODELENS;

  00b73	41 c7 06 12 00
	00 00		 mov	 DWORD PTR [r14], 18
$LN528@inflate:

; 935  :         case CODELENS:
; 936  :             while (state->have < state->nlen + state->ndist) {

  00b7a	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00b7e	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00b82	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00b86	0f 83 eb 01 00
	00		 jae	 $LN218@inflate
  00b8c	0f 1f 40 00	 npad	 4
$LL219@inflate:

; 937  :                 for (;;) {
; 938  :                     here = state->lencode[BITS(state->lenbits)];

  00b90	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00b94	b8 01 00 00 00	 mov	 eax, 1
  00b99	d3 e0		 shl	 eax, cl
  00b9b	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b9e	41 8b c5	 mov	 eax, r13d
  00ba1	48 23 c8	 and	 rcx, rax
  00ba4	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00ba8	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 939  :                     if ((unsigned)(here.bits) <= bits) break;

  00bab	8b c8		 mov	 ecx, eax
  00bad	89 45 b8	 mov	 DWORD PTR here$[rbp-128], eax
  00bb0	c1 e9 08	 shr	 ecx, 8
  00bb3	0f b6 c9	 movzx	 ecx, cl
  00bb6	3b cf		 cmp	 ecx, edi
  00bb8	76 4c		 jbe	 SHORT $LN555@inflate
  00bba	66 0f 1f 44 00
	00		 npad	 6
$LL217@inflate:

; 940  :                     PULLBYTE();

  00bc0	85 f6		 test	 esi, esi
  00bc2	0f 84 95 fc ff
	ff		 je	 $LN765@inflate
  00bc8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00bcd	8b cf		 mov	 ecx, edi
  00bcf	83 c7 08	 add	 edi, 8
  00bd2	d3 e0		 shl	 eax, cl
  00bd4	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00bd8	ff ce		 dec	 esi
  00bda	44 03 e8	 add	 r13d, eax
  00bdd	b8 01 00 00 00	 mov	 eax, 1
  00be2	49 ff c4	 inc	 r12
  00be5	d3 e0		 shl	 eax, cl
  00be7	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bea	41 8b c5	 mov	 eax, r13d
  00bed	48 23 c8	 and	 rcx, rax
  00bf0	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00bf4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bf7	8b c8		 mov	 ecx, eax
  00bf9	89 45 b8	 mov	 DWORD PTR here$[rbp-128], eax
  00bfc	c1 e9 08	 shr	 ecx, 8
  00bff	0f b6 c9	 movzx	 ecx, cl
  00c02	3b cf		 cmp	 ecx, edi
  00c04	77 ba		 ja	 SHORT $LL217@inflate
$LN555@inflate:

; 941  :                 }
; 942  :                 if (here.val < 16) {

  00c06	8b d0		 mov	 edx, eax
  00c08	c1 ea 10	 shr	 edx, 16
  00c0b	66 83 fa 10	 cmp	 dx, 16
  00c0f	73 21		 jae	 SHORT $LN799@inflate

; 943  :                     DROPBITS(here.bits);

  00c11	c1 e8 08	 shr	 eax, 8
  00c14	0f b6 c8	 movzx	 ecx, al

; 944  :                     state->lens[state->have++] = here.val;

  00c17	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00c1b	66 41 89 94 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], dx
  00c24	41 d3 ed	 shr	 r13d, cl
  00c27	2b f9		 sub	 edi, ecx
  00c29	41 ff 46 7c	 inc	 DWORD PTR [r14+124]

; 945  :                 }
; 946  :                 else {

  00c2d	e9 33 01 00 00	 jmp	 $LN603@inflate
$LN799@inflate:

; 947  :                     if (here.val == 16) {

  00c32	75 6b		 jne	 SHORT $LN205@inflate

; 948  :                         NEEDBITS(here.bits + 2);

  00c34	0f b6 55 b9	 movzx	 edx, BYTE PTR here$[rbp-127]
  00c38	c1 e8 08	 shr	 eax, 8
  00c3b	0f b6 c8	 movzx	 ecx, al
  00c3e	83 c1 02	 add	 ecx, 2
  00c41	3b f9		 cmp	 edi, ecx
  00c43	73 26		 jae	 SHORT $LN203@inflate
$LL201@inflate:
  00c45	85 f6		 test	 esi, esi
  00c47	0f 84 10 fc ff
	ff		 je	 $LN765@inflate
  00c4d	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00c52	8b cf		 mov	 ecx, edi
  00c54	83 c7 08	 add	 edi, 8
  00c57	d3 e0		 shl	 eax, cl
  00c59	ff ce		 dec	 esi
  00c5b	49 ff c4	 inc	 r12
  00c5e	44 03 e8	 add	 r13d, eax
  00c61	0f b6 c2	 movzx	 eax, dl
  00c64	83 c0 02	 add	 eax, 2
  00c67	3b f8		 cmp	 edi, eax
  00c69	72 da		 jb	 SHORT $LL201@inflate
$LN203@inflate:

; 949  :                         DROPBITS(here.bits);
; 950  :                         if (state->have == 0) {

  00c6b	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00c6f	0f b6 ca	 movzx	 ecx, dl
  00c72	41 d3 ed	 shr	 r13d, cl
  00c75	2b f9		 sub	 edi, ecx
  00c77	85 c0		 test	 eax, eax
  00c79	0f 84 24 01 00
	00		 je	 $LN560@inflate

; 954  :                         }
; 955  :                         len = state->lens[state->have - 1];
; 956  :                         copy = 3 + BITS(2);

  00c7f	41 8b d5	 mov	 edx, r13d
  00c82	ff c8		 dec	 eax

; 957  :                         DROPBITS(2);

  00c84	41 c1 ed 02	 shr	 r13d, 2
  00c88	45 0f b7 84 46
	88 00 00 00	 movzx	 r8d, WORD PTR [r14+rax*2+136]
  00c91	83 e2 03	 and	 edx, 3
  00c94	83 c2 03	 add	 edx, 3
  00c97	83 c7 fe	 add	 edi, -2			; fffffffeH

; 958  :                     }
; 959  :                     else if (here.val == 17) {

  00c9a	e9 96 00 00 00	 jmp	 $LN156@inflate
$LN205@inflate:
  00c9f	66 83 7d ba 11	 cmp	 WORD PTR here$[rbp-126], 17
  00ca4	44 0f b6 4d b9	 movzx	 r9d, BYTE PTR here$[rbp-127]
  00ca9	75 42		 jne	 SHORT $LN170@inflate

; 960  :                         NEEDBITS(here.bits + 3);

  00cab	41 8d 51 03	 lea	 edx, DWORD PTR [r9+3]
  00caf	3b fa		 cmp	 edi, edx
  00cb1	73 20		 jae	 SHORT $LN185@inflate
$LL183@inflate:
  00cb3	85 f6		 test	 esi, esi
  00cb5	0f 84 a2 fb ff
	ff		 je	 $LN765@inflate
  00cbb	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00cc0	8b cf		 mov	 ecx, edi
  00cc2	83 c7 08	 add	 edi, 8
  00cc5	d3 e0		 shl	 eax, cl
  00cc7	ff ce		 dec	 esi
  00cc9	49 ff c4	 inc	 r12
  00ccc	44 03 e8	 add	 r13d, eax
  00ccf	3b fa		 cmp	 edi, edx
  00cd1	72 e0		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 961  :                         DROPBITS(here.bits);

  00cd3	41 8b c9	 mov	 ecx, r9d

; 962  :                         len = 0;
; 963  :                         copy = 3 + BITS(3);
; 964  :                         DROPBITS(3);

  00cd6	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00cdb	41 d3 ed	 shr	 r13d, cl
  00cde	41 8b d5	 mov	 edx, r13d
  00ce1	83 e2 07	 and	 edx, 7
  00ce4	83 c2 03	 add	 edx, 3
  00ce7	41 c1 ed 03	 shr	 r13d, 3

; 965  :                     }
; 966  :                     else {

  00ceb	eb 40		 jmp	 SHORT $LN800@inflate
$LN170@inflate:

; 967  :                         NEEDBITS(here.bits + 7);

  00ced	41 8d 51 07	 lea	 edx, DWORD PTR [r9+7]
  00cf1	3b fa		 cmp	 edi, edx
  00cf3	73 20		 jae	 SHORT $LN169@inflate
$LL167@inflate:
  00cf5	85 f6		 test	 esi, esi
  00cf7	0f 84 60 fb ff
	ff		 je	 $LN765@inflate
  00cfd	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00d02	8b cf		 mov	 ecx, edi
  00d04	83 c7 08	 add	 edi, 8
  00d07	d3 e0		 shl	 eax, cl
  00d09	ff ce		 dec	 esi
  00d0b	49 ff c4	 inc	 r12
  00d0e	44 03 e8	 add	 r13d, eax
  00d11	3b fa		 cmp	 edi, edx
  00d13	72 e0		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 968  :                         DROPBITS(here.bits);

  00d15	41 8b c9	 mov	 ecx, r9d

; 969  :                         len = 0;
; 970  :                         copy = 11 + BITS(7);
; 971  :                         DROPBITS(7);

  00d18	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d1d	41 d3 ed	 shr	 r13d, cl
  00d20	41 8b d5	 mov	 edx, r13d
  00d23	83 e2 7f	 and	 edx, 127		; 0000007fH
  00d26	83 c2 0b	 add	 edx, 11
  00d29	41 c1 ed 07	 shr	 r13d, 7
$LN800@inflate:
  00d2d	41 2b c1	 sub	 eax, r9d
  00d30	45 8b c7	 mov	 r8d, r15d
  00d33	03 f8		 add	 edi, eax
$LN156@inflate:

; 972  :                     }
; 973  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d35	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00d39	8d 0c 02	 lea	 ecx, DWORD PTR [rdx+rax]
  00d3c	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00d40	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00d44	3b c8		 cmp	 ecx, eax
  00d46	77 5b		 ja	 SHORT $LN560@inflate

; 974  :                         strm->msg = (char *)"invalid bit length repeat";
; 975  :                         state->mode = BAD;
; 976  :                         break;
; 977  :                     }
; 978  :                     while (copy--)

  00d48	85 d2		 test	 edx, edx
  00d4a	74 19		 je	 SHORT $LN603@inflate
  00d4c	0f 1f 40 00	 npad	 4
$LL154@inflate:

; 979  :                         state->lens[state->have++] = (unsigned short)len;

  00d50	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00d54	66 45 89 84 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], r8w
  00d5d	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00d61	ff ca		 dec	 edx
  00d63	75 eb		 jne	 SHORT $LL154@inflate
$LN603@inflate:

; 935  :         case CODELENS:
; 936  :             while (state->have < state->nlen + state->ndist) {

  00d65	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00d69	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00d6d	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00d71	0f 82 19 fe ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 980  :                 }
; 981  :             }
; 982  : 
; 983  :             /* handle error breaks in while */
; 984  :             if (state->mode == BAD) break;

  00d77	41 83 3e 1d	 cmp	 DWORD PTR [r14], 29
  00d7b	0f 84 5a f9 ff
	ff		 je	 $LN730@inflate

; 985  : 
; 986  :             /* check for end-of-block code (better have one) */
; 987  :             if (state->lens[256] == 0) {

  00d81	66 41 83 be 88
	02 00 00 00	 cmp	 WORD PTR [r14+648], 0
  00d8a	75 2e		 jne	 SHORT $LN151@inflate

; 988  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d8c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00d93	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 989  :                 state->mode = BAD;

  00d97	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 990  :                 break;

  00d9e	e9 38 f9 ff ff	 jmp	 $LN730@inflate
$LN560@inflate:

; 951  :                             strm->msg = (char *)"invalid bit length repeat";

  00da3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00daa	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 952  :                             state->mode = BAD;

  00dae	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 953  :                             break;

  00db5	e9 21 f9 ff ff	 jmp	 $LN730@inflate
$LN151@inflate:

; 991  :             }
; 992  : 
; 993  :             /* build code tables -- note: do not change the lenbits or distbits
; 994  :                values here (9 and 6) without reading the comments in inftrees.h
; 995  :                concerning the ENOUGH constants, which depend on those values */
; 996  :             state->next = state->codes;
; 997  :             state->lencode = (code const FAR *)(state->next);
; 998  :             state->lenbits = 9;
; 999  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1000 :                                 &(state->lenbits), state->work);

  00dba	45 8b 46 74	 mov	 r8d, DWORD PTR [r14+116]
  00dbe	49 8d 86 48 05
	00 00		 lea	 rax, QWORD PTR [r14+1352]
  00dc5	4d 8d be 08 03
	00 00		 lea	 r15, QWORD PTR [r14+776]
  00dcc	49 89 86 80 00
	00 00		 mov	 QWORD PTR [r14+128], rax
  00dd3	49 89 46 58	 mov	 QWORD PTR [r14+88], rax
  00dd7	49 8d 46 68	 lea	 rax, QWORD PTR [r14+104]
  00ddb	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00de2	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00de9	b9 01 00 00 00	 mov	 ecx, 1
  00dee	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00df3	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00df9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dfe	e8 00 00 00 00	 call	 inflate_table
  00e03	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 1001 :             if (ret) {

  00e06	85 c0		 test	 eax, eax
  00e08	74 1b		 je	 SHORT $LN150@inflate

; 1002 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e0a	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00e0e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00e15	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1003 :                 state->mode = BAD;

  00e19	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 1004 :                 break;

  00e20	e9 b2 f8 ff ff	 jmp	 $LN803@inflate
$LN150@inflate:

; 1005 :             }
; 1006 :             state->distcode = (code const FAR *)(state->next);

  00e25	49 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [r14+128]

; 1007 :             state->distbits = 6;
; 1008 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1009 :                             &(state->next), &(state->distbits), state->work);

  00e2c	45 8b 46 78	 mov	 r8d, DWORD PTR [r14+120]
  00e30	49 8d 4e 6c	 lea	 rcx, QWORD PTR [r14+108]
  00e34	49 89 46 60	 mov	 QWORD PTR [r14+96], rax
  00e38	41 8b 46 74	 mov	 eax, DWORD PTR [r14+116]
  00e3c	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00e42	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00e47	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00e4c	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00e53	49 8d 94 46 88
	00 00 00	 lea	 rdx, QWORD PTR [r14+rax*2+136]
  00e5b	b9 02 00 00 00	 mov	 ecx, 2
  00e60	e8 00 00 00 00	 call	 inflate_table
  00e65	44 8b f8	 mov	 r15d, eax
  00e68	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 1010 :             if (ret) {

  00e6b	85 c0		 test	 eax, eax
  00e6d	74 1b		 je	 SHORT $LN149@inflate

; 1011 :                 strm->msg = (char *)"invalid distances set";

  00e6f	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00e73	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00e7a	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1012 :                 state->mode = BAD;

  00e7e	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 1013 :                 break;

  00e85	e9 4d f8 ff ff	 jmp	 $LN803@inflate
$LN149@inflate:

; 1014 :             }
; 1015 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1016 :             state->mode = LEN_;
; 1017 :             if (flush == Z_TREES) goto inf_leave;

  00e8a	8b 4d 28	 mov	 ecx, DWORD PTR flush$[rbp-128]
  00e8d	41 c7 06 13 00
	00 00		 mov	 DWORD PTR [r14], 19
  00e94	83 f9 06	 cmp	 ecx, 6
  00e97	0f 84 c7 f9 ff
	ff		 je	 $inf_leave$81100
  00e9d	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00ea1	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00ea5	44 8b 45 b4	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  00ea9	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  00ead	45 33 ff	 xor	 r15d, r15d
$LN148@inflate:

; 1018 :         case LEN_:
; 1019 :             state->mode = LEN;

  00eb0	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20
$LN146@inflate:

; 1020 :         case LEN:
; 1021 :             if (have >= 6 && left >= 258) {

  00eb7	83 fe 06	 cmp	 esi, 6
  00eba	72 62		 jb	 SHORT $LN145@inflate
  00ebc	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00ec3	72 59		 jb	 SHORT $LN145@inflate

; 1022 :                 RESTORE();

  00ec5	4c 89 4b 10	 mov	 QWORD PTR [rbx+16], r9
  00ec9	44 89 53 18	 mov	 DWORD PTR [rbx+24], r10d
  00ecd	4c 89 23	 mov	 QWORD PTR [rbx], r12
  00ed0	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 1023 :                 inflate_fast(strm, out);

  00ed3	41 8b d0	 mov	 edx, r8d
  00ed6	48 8b cb	 mov	 rcx, rbx
  00ed9	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  00edd	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  00ee1	e8 00 00 00 00	 call	 inflate_fast

; 1024 :                 LOAD();
; 1025 :                 if (state->mode == TYPE)

  00ee6	41 83 3e 0b	 cmp	 DWORD PTR [r14], 11
  00eea	4c 8b 4b 10	 mov	 r9, QWORD PTR [rbx+16]
  00eee	44 8b 53 18	 mov	 r10d, DWORD PTR [rbx+24]
  00ef2	4c 8b 23	 mov	 r12, QWORD PTR [rbx]
  00ef5	8b 73 08	 mov	 esi, DWORD PTR [rbx+8]
  00ef8	45 8b 6e 40	 mov	 r13d, DWORD PTR [r14+64]
  00efc	41 8b 7e 44	 mov	 edi, DWORD PTR [r14+68]
  00f00	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00f04	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00f08	0f 85 d1 f7 ff
	ff		 jne	 $LN490@inflate

; 1026 :                     state->back = -1;

  00f0e	41 c7 86 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r14+7132], -1

; 1027 :                 break;

  00f19	e9 c1 f7 ff ff	 jmp	 $LN490@inflate
$LN145@inflate:

; 1028 :             }
; 1029 :             state->back = 0;
; 1030 :             for (;;) {
; 1031 :                 here = state->lencode[BITS(state->lenbits)];

  00f1e	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00f22	4d 8b 5e 58	 mov	 r11, QWORD PTR [r14+88]
  00f26	b8 01 00 00 00	 mov	 eax, 1
  00f2b	d3 e0		 shl	 eax, cl
  00f2d	45 89 be dc 1b
	00 00		 mov	 DWORD PTR [r14+7132], r15d
  00f34	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f37	41 8b c5	 mov	 eax, r13d
  00f3a	48 23 c8	 and	 rcx, rax
  00f3d	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1032 :                 if ((unsigned)(here.bits) <= bits) break;

  00f41	8b c8		 mov	 ecx, eax
  00f43	c1 e9 08	 shr	 ecx, 8
  00f46	0f b6 c9	 movzx	 ecx, cl
  00f49	3b cf		 cmp	 ecx, edi
  00f4b	76 46		 jbe	 SHORT $LN562@inflate
  00f4d	0f 1f 00	 npad	 3
$LL137@inflate:

; 1033 :                 PULLBYTE();

  00f50	85 f6		 test	 esi, esi
  00f52	0f 84 05 f9 ff
	ff		 je	 $LN765@inflate
  00f58	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00f5d	8b cf		 mov	 ecx, edi
  00f5f	83 c7 08	 add	 edi, 8
  00f62	d3 e0		 shl	 eax, cl
  00f64	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00f68	ff ce		 dec	 esi
  00f6a	44 03 e8	 add	 r13d, eax
  00f6d	b8 01 00 00 00	 mov	 eax, 1
  00f72	49 ff c4	 inc	 r12
  00f75	d3 e0		 shl	 eax, cl
  00f77	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f7a	41 8b c5	 mov	 eax, r13d
  00f7d	48 23 c8	 and	 rcx, rax
  00f80	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00f84	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00f87	8b c8		 mov	 ecx, eax
  00f89	c1 e9 08	 shr	 ecx, 8
  00f8c	0f b6 c9	 movzx	 ecx, cl
  00f8f	3b cf		 cmp	 ecx, edi
  00f91	77 bd		 ja	 SHORT $LL137@inflate
$LN562@inflate:

; 1034 :             }
; 1035 :             if (here.op && (here.op & 0xf0) == 0) {

  00f93	84 c0		 test	 al, al
  00f95	0f 84 c7 00 00
	00		 je	 $LN119@inflate
  00f9b	a8 f0		 test	 al, 240			; 000000f0H
  00f9d	0f 85 bf 00 00
	00		 jne	 $LN119@inflate

; 1036 :                 last = here;
; 1037 :                 for (;;) {
; 1038 :                     here = state->lencode[last.val +
; 1039 :                             (BITS(last.bits + last.op) >> last.bits)];

  00fa3	44 8b d0	 mov	 r10d, eax
  00fa6	0f b6 c8	 movzx	 ecx, al
  00fa9	89 45 b8	 mov	 DWORD PTR last$[rbp-128], eax
  00fac	41 c1 ea 08	 shr	 r10d, 8
  00fb0	41 b9 01 00 00
	00		 mov	 r9d, 1
  00fb6	8b d0		 mov	 edx, eax
  00fb8	45 0f b6 c2	 movzx	 r8d, r10b
  00fbc	c1 e8 10	 shr	 eax, 16
  00fbf	41 03 c8	 add	 ecx, r8d
  00fc2	41 d3 e1	 shl	 r9d, cl
  00fc5	41 8b c8	 mov	 ecx, r8d
  00fc8	41 ff c9	 dec	 r9d
  00fcb	45 23 cd	 and	 r9d, r13d
  00fce	41 d3 e9	 shr	 r9d, cl
  00fd1	44 03 c8	 add	 r9d, eax
  00fd4	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1040 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fd8	44 0f b6 5d b9	 movzx	 r11d, BYTE PTR last$[rbp-127]
  00fdd	8b c8		 mov	 ecx, eax
  00fdf	c1 e9 08	 shr	 ecx, 8
  00fe2	44 0f b6 c1	 movzx	 r8d, cl
  00fe6	41 0f b6 ca	 movzx	 ecx, r10b
  00fea	44 03 c1	 add	 r8d, ecx
  00fed	44 3b c7	 cmp	 r8d, edi
  00ff0	76 60		 jbe	 SHORT $LN122@inflate
  00ff2	44 0f b7 55 ba	 movzx	 r10d, WORD PTR last$[rbp-126]
$LL129@inflate:

; 1041 :                     PULLBYTE();

  00ff7	85 f6		 test	 esi, esi
  00ff9	0f 84 5e f8 ff
	ff		 je	 $LN765@inflate
  00fff	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  01004	8b cf		 mov	 ecx, edi
  01006	45 0f b6 cb	 movzx	 r9d, r11b
  0100a	d3 e0		 shl	 eax, cl
  0100c	41 b8 01 00 00
	00		 mov	 r8d, 1
  01012	0f b6 ca	 movzx	 ecx, dl
  01015	41 03 c9	 add	 ecx, r9d
  01018	44 03 e8	 add	 r13d, eax
  0101b	41 0f b7 c2	 movzx	 eax, r10w
  0101f	41 d3 e0	 shl	 r8d, cl
  01022	41 8b c9	 mov	 ecx, r9d
  01025	83 c7 08	 add	 edi, 8
  01028	41 ff c8	 dec	 r8d
  0102b	ff ce		 dec	 esi
  0102d	49 ff c4	 inc	 r12
  01030	45 23 c5	 and	 r8d, r13d
  01033	41 d3 e8	 shr	 r8d, cl
  01036	44 03 c0	 add	 r8d, eax
  01039	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  0103d	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  01041	8b c8		 mov	 ecx, eax
  01043	c1 e9 08	 shr	 ecx, 8
  01046	44 0f b6 c1	 movzx	 r8d, cl
  0104a	45 03 c1	 add	 r8d, r9d
  0104d	44 3b c7	 cmp	 r8d, edi
  01050	77 a5		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1042 :                 }
; 1043 :                 DROPBITS(last.bits);

  01052	41 0f b6 cb	 movzx	 ecx, r11b
  01056	41 d3 ed	 shr	 r13d, cl
  01059	2b f9		 sub	 edi, ecx

; 1044 :                 state->back += last.bits;

  0105b	41 89 8e dc 1b
	00 00		 mov	 DWORD PTR [r14+7132], ecx
$LN119@inflate:

; 1045 :             }
; 1046 :             DROPBITS(here.bits);

  01062	8b c8		 mov	 ecx, eax
  01064	c1 e9 08	 shr	 ecx, 8
  01067	0f b6 c9	 movzx	 ecx, cl

; 1047 :             state->back += here.bits;

  0106a	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
  01071	41 d3 ed	 shr	 r13d, cl
  01074	2b f9		 sub	 edi, ecx

; 1048 :             state->length = (unsigned)here.val;

  01076	8b c8		 mov	 ecx, eax
  01078	c1 e9 10	 shr	 ecx, 16
  0107b	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 1049 :             if ((int)(here.op) == 0) {

  0107f	84 c0		 test	 al, al
  01081	75 0c		 jne	 SHORT $LN116@inflate

; 1050 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1051 :                         "inflate:         literal '%c'\n" :
; 1052 :                         "inflate:         literal 0x%02x\n", here.val));
; 1053 :                 state->mode = LIT;

  01083	41 c7 06 19 00
	00 00		 mov	 DWORD PTR [r14], 25

; 1054 :                 break;

  0108a	e9 48 f6 ff ff	 jmp	 $LN803@inflate
$LN116@inflate:

; 1055 :             }
; 1056 :             if (here.op & 32) {

  0108f	a8 20		 test	 al, 32			; 00000020H
  01091	74 10		 je	 SHORT $LN115@inflate

; 1057 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1058 :                 state->back = -1;

  01093	41 c7 86 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r14+7132], -1

; 1060 :                 break;

  0109e	e9 2d f6 ff ff	 jmp	 $LN808@inflate
$LN115@inflate:

; 1061 :             }
; 1062 :             if (here.op & 64) {

  010a3	a8 40		 test	 al, 64			; 00000040H
  010a5	74 17		 je	 SHORT $LN114@inflate

; 1063 :                 strm->msg = (char *)"invalid literal/length code";

  010a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010ae	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1064 :                 state->mode = BAD;

  010b2	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 1065 :                 break;

  010b9	e9 19 f6 ff ff	 jmp	 $LN803@inflate
$LN114@inflate:

; 1066 :             }
; 1067 :             state->extra = (unsigned)(here.op) & 15;

  010be	0f b6 c8	 movzx	 ecx, al

; 1068 :             state->mode = LENEXT;

  010c1	41 c7 06 15 00
	00 00		 mov	 DWORD PTR [r14], 21
  010c8	83 e1 0f	 and	 ecx, 15
  010cb	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx
$LN113@inflate:

; 1069 :         case LENEXT:
; 1070 :             if (state->extra) {

  010cf	41 8b 56 50	 mov	 edx, DWORD PTR [r14+80]
  010d3	85 d2		 test	 edx, edx
  010d5	74 49		 je	 SHORT $LN112@inflate

; 1071 :                 NEEDBITS(state->extra);

  010d7	3b fa		 cmp	 edi, edx
  010d9	73 27		 jae	 SHORT $LN110@inflate
  010db	0f 1f 44 00 00	 npad	 5
$LL108@inflate:
  010e0	85 f6		 test	 esi, esi
  010e2	0f 84 75 f7 ff
	ff		 je	 $LN765@inflate
  010e8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  010ed	8b cf		 mov	 ecx, edi
  010ef	83 c7 08	 add	 edi, 8
  010f2	d3 e0		 shl	 eax, cl
  010f4	ff ce		 dec	 esi
  010f6	49 ff c4	 inc	 r12
  010f9	44 03 e8	 add	 r13d, eax
  010fc	41 3b 7e 50	 cmp	 edi, DWORD PTR [r14+80]
  01100	72 de		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1072 :                 state->length += BITS(state->extra);

  01102	8b ca		 mov	 ecx, edx
  01104	b8 01 00 00 00	 mov	 eax, 1

; 1073 :                 DROPBITS(state->extra);

  01109	2b fa		 sub	 edi, edx
  0110b	d3 e0		 shl	 eax, cl
  0110d	ff c8		 dec	 eax
  0110f	41 23 c5	 and	 eax, r13d
  01112	41 d3 ed	 shr	 r13d, cl
  01115	41 01 46 48	 add	 DWORD PTR [r14+72], eax

; 1074 :                 state->back += state->extra;

  01119	41 01 96 dc 1b
	00 00		 add	 DWORD PTR [r14+7132], edx
$LN112@inflate:

; 1075 :             }
; 1076 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1077 :             state->was = state->length;

  01120	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]

; 1078 :             state->mode = DIST;

  01124	41 c7 06 16 00
	00 00		 mov	 DWORD PTR [r14], 22
  0112b	41 89 86 e0 1b
	00 00		 mov	 DWORD PTR [r14+7136], eax
$LN537@inflate:

; 1079 :         case DIST:
; 1080 :             for (;;) {
; 1081 :                 here = state->distcode[BITS(state->distbits)];

  01132	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]
  01136	4d 8b 5e 60	 mov	 r11, QWORD PTR [r14+96]
  0113a	b8 01 00 00 00	 mov	 eax, 1
  0113f	d3 e0		 shl	 eax, cl
  01141	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01144	41 8b c5	 mov	 eax, r13d
  01147	48 23 c8	 and	 rcx, rax
  0114a	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1082 :                 if ((unsigned)(here.bits) <= bits) break;

  0114e	8b c8		 mov	 ecx, eax
  01150	c1 e9 08	 shr	 ecx, 8
  01153	0f b6 c9	 movzx	 ecx, cl
  01156	3b cf		 cmp	 ecx, edi
  01158	76 49		 jbe	 SHORT $LN567@inflate
  0115a	66 0f 1f 44 00
	00		 npad	 6
$LL98@inflate:

; 1083 :                 PULLBYTE();

  01160	85 f6		 test	 esi, esi
  01162	0f 84 f5 f6 ff
	ff		 je	 $LN765@inflate
  01168	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0116d	8b cf		 mov	 ecx, edi
  0116f	83 c7 08	 add	 edi, 8
  01172	d3 e0		 shl	 eax, cl
  01174	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]
  01178	ff ce		 dec	 esi
  0117a	44 03 e8	 add	 r13d, eax
  0117d	b8 01 00 00 00	 mov	 eax, 1
  01182	49 ff c4	 inc	 r12
  01185	d3 e0		 shl	 eax, cl
  01187	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0118a	41 8b c5	 mov	 eax, r13d
  0118d	48 23 c8	 and	 rcx, rax
  01190	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  01194	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01197	8b c8		 mov	 ecx, eax
  01199	c1 e9 08	 shr	 ecx, 8
  0119c	0f b6 c9	 movzx	 ecx, cl
  0119f	3b cf		 cmp	 ecx, edi
  011a1	77 bd		 ja	 SHORT $LL98@inflate
$LN567@inflate:

; 1084 :             }
; 1085 :             if ((here.op & 0xf0) == 0) {

  011a3	a8 f0		 test	 al, 240			; 000000f0H
  011a5	0f 85 c0 00 00
	00		 jne	 $LN80@inflate

; 1086 :                 last = here;
; 1087 :                 for (;;) {
; 1088 :                     here = state->distcode[last.val +
; 1089 :                             (BITS(last.bits + last.op) >> last.bits)];

  011ab	44 8b d0	 mov	 r10d, eax
  011ae	0f b6 c8	 movzx	 ecx, al
  011b1	89 45 b8	 mov	 DWORD PTR last$[rbp-128], eax
  011b4	41 c1 ea 08	 shr	 r10d, 8
  011b8	41 b9 01 00 00
	00		 mov	 r9d, 1
  011be	8b d0		 mov	 edx, eax
  011c0	45 0f b6 c2	 movzx	 r8d, r10b
  011c4	c1 e8 10	 shr	 eax, 16
  011c7	41 03 c8	 add	 ecx, r8d
  011ca	41 d3 e1	 shl	 r9d, cl
  011cd	41 8b c8	 mov	 ecx, r8d
  011d0	41 ff c9	 dec	 r9d
  011d3	45 23 cd	 and	 r9d, r13d
  011d6	41 d3 e9	 shr	 r9d, cl
  011d9	44 03 c8	 add	 r9d, eax
  011dc	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1090 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011e0	44 0f b6 5d b9	 movzx	 r11d, BYTE PTR last$[rbp-127]
  011e5	8b c8		 mov	 ecx, eax
  011e7	c1 e9 08	 shr	 ecx, 8
  011ea	44 0f b6 c1	 movzx	 r8d, cl
  011ee	41 0f b6 ca	 movzx	 ecx, r10b
  011f2	44 03 c1	 add	 r8d, ecx
  011f5	44 3b c7	 cmp	 r8d, edi
  011f8	76 61		 jbe	 SHORT $LN83@inflate
  011fa	44 0f b7 55 ba	 movzx	 r10d, WORD PTR last$[rbp-126]
  011ff	90		 npad	 1
$LL90@inflate:

; 1091 :                     PULLBYTE();

  01200	85 f6		 test	 esi, esi
  01202	0f 84 55 f6 ff
	ff		 je	 $LN765@inflate
  01208	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0120d	8b cf		 mov	 ecx, edi
  0120f	45 0f b6 cb	 movzx	 r9d, r11b
  01213	d3 e0		 shl	 eax, cl
  01215	41 b8 01 00 00
	00		 mov	 r8d, 1
  0121b	0f b6 ca	 movzx	 ecx, dl
  0121e	41 03 c9	 add	 ecx, r9d
  01221	44 03 e8	 add	 r13d, eax
  01224	41 0f b7 c2	 movzx	 eax, r10w
  01228	41 d3 e0	 shl	 r8d, cl
  0122b	41 8b c9	 mov	 ecx, r9d
  0122e	83 c7 08	 add	 edi, 8
  01231	41 ff c8	 dec	 r8d
  01234	ff ce		 dec	 esi
  01236	49 ff c4	 inc	 r12
  01239	45 23 c5	 and	 r8d, r13d
  0123c	41 d3 e8	 shr	 r8d, cl
  0123f	44 03 c0	 add	 r8d, eax
  01242	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  01246	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0124a	8b c8		 mov	 ecx, eax
  0124c	c1 e9 08	 shr	 ecx, 8
  0124f	44 0f b6 c1	 movzx	 r8d, cl
  01253	45 03 c1	 add	 r8d, r9d
  01256	44 3b c7	 cmp	 r8d, edi
  01259	77 a5		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1092 :                 }
; 1093 :                 DROPBITS(last.bits);

  0125b	41 0f b6 cb	 movzx	 ecx, r11b
  0125f	41 d3 ed	 shr	 r13d, cl
  01262	2b f9		 sub	 edi, ecx

; 1094 :                 state->back += last.bits;

  01264	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
$LN80@inflate:

; 1095 :             }
; 1096 :             DROPBITS(here.bits);
; 1097 :             state->back += here.bits;
; 1098 :             if (here.op & 64) {
; 1099 :                 strm->msg = (char *)"invalid distance code";
; 1100 :                 state->mode = BAD;
; 1101 :                 break;

  0126b	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0126f	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  01273	8b c8		 mov	 ecx, eax
  01275	c1 e9 08	 shr	 ecx, 8
  01278	0f b6 c9	 movzx	 ecx, cl
  0127b	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
  01282	41 d3 ed	 shr	 r13d, cl
  01285	2b f9		 sub	 edi, ecx
  01287	a8 40		 test	 al, 64			; 00000040H
  01289	74 17		 je	 SHORT $LN77@inflate

; 666  :                 strm->msg = (char *)"unknown compression method";

  0128b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  01292	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 667  :                 state->mode = BAD;

  01296	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 668  :                 break;

  0129d	e9 3d f4 ff ff	 jmp	 $LN490@inflate
$LN77@inflate:
  012a2	44 8b 45 b4	 mov	 r8d, DWORD PTR out$1$[rbp-128]

; 1102 :             }
; 1103 :             state->offset = (unsigned)here.val;

  012a6	8b c8		 mov	 ecx, eax

; 1104 :             state->extra = (unsigned)(here.op) & 15;
; 1105 :             state->mode = DISTEXT;

  012a8	41 c7 06 17 00
	00 00		 mov	 DWORD PTR [r14], 23
  012af	c1 e9 10	 shr	 ecx, 16
  012b2	41 89 4e 4c	 mov	 DWORD PTR [r14+76], ecx
  012b6	0f b6 c8	 movzx	 ecx, al
  012b9	83 e1 0f	 and	 ecx, 15
  012bc	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx
$LN76@inflate:

; 1106 :         case DISTEXT:
; 1107 :             if (state->extra) {

  012c0	41 8b 56 50	 mov	 edx, DWORD PTR [r14+80]
  012c4	85 d2		 test	 edx, edx
  012c6	74 48		 je	 SHORT $LN75@inflate

; 1108 :                 NEEDBITS(state->extra);

  012c8	3b fa		 cmp	 edi, edx
  012ca	73 26		 jae	 SHORT $LN73@inflate
  012cc	0f 1f 40 00	 npad	 4
$LL71@inflate:
  012d0	85 f6		 test	 esi, esi
  012d2	0f 84 85 f5 ff
	ff		 je	 $LN765@inflate
  012d8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  012dd	8b cf		 mov	 ecx, edi
  012df	83 c7 08	 add	 edi, 8
  012e2	d3 e0		 shl	 eax, cl
  012e4	ff ce		 dec	 esi
  012e6	49 ff c4	 inc	 r12
  012e9	44 03 e8	 add	 r13d, eax
  012ec	41 3b 7e 50	 cmp	 edi, DWORD PTR [r14+80]
  012f0	72 de		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1109 :                 state->offset += BITS(state->extra);

  012f2	8b ca		 mov	 ecx, edx
  012f4	b8 01 00 00 00	 mov	 eax, 1

; 1110 :                 DROPBITS(state->extra);

  012f9	2b fa		 sub	 edi, edx
  012fb	d3 e0		 shl	 eax, cl
  012fd	ff c8		 dec	 eax
  012ff	41 23 c5	 and	 eax, r13d
  01302	41 d3 ed	 shr	 r13d, cl
  01305	41 01 46 4c	 add	 DWORD PTR [r14+76], eax

; 1111 :                 state->back += state->extra;

  01309	41 01 96 dc 1b
	00 00		 add	 DWORD PTR [r14+7132], edx
$LN75@inflate:

; 1112 :             }
; 1113 : #ifdef INFLATE_STRICT
; 1114 :             if (state->offset > state->dmax) {
; 1115 :                 strm->msg = (char *)"invalid distance too far back";
; 1116 :                 state->mode = BAD;
; 1117 :                 break;
; 1118 :             }
; 1119 : #endif
; 1120 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1121 :             state->mode = MATCH;

  01310	41 c7 06 18 00
	00 00		 mov	 DWORD PTR [r14], 24
$LN62@inflate:

; 1122 :         case MATCH:
; 1123 :             if (left == 0) goto inf_leave;

  01317	45 85 d2	 test	 r10d, r10d
  0131a	0f 84 3d f5 ff
	ff		 je	 $LN765@inflate

; 1124 :             copy = out - left;
; 1125 :             if (state->offset > copy) {         /* copy from window */

  01320	41 8b 4e 4c	 mov	 ecx, DWORD PTR [r14+76]
  01324	41 8b c0	 mov	 eax, r8d
  01327	41 2b c2	 sub	 eax, r10d
  0132a	3b c8		 cmp	 ecx, eax
  0132c	76 4d		 jbe	 SHORT $LN60@inflate

; 1126 :                 copy = state->offset - copy;

  0132e	2b c8		 sub	 ecx, eax

; 1127 :                 if (copy > state->whave) {

  01330	41 3b 4e 30	 cmp	 ecx, DWORD PTR [r14+48]
  01334	76 21		 jbe	 SHORT $LN58@inflate

; 1128 :                     if (state->sane) {

  01336	41 83 be d8 1b
	00 00 00	 cmp	 DWORD PTR [r14+7128], 0
  0133e	74 17		 je	 SHORT $LN58@inflate

; 1129 :                         strm->msg = (char *)"invalid distance too far back";

  01340	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  01347	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0134b	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  01352	e9 88 f3 ff ff	 jmp	 $LN490@inflate
$LN58@inflate:

; 1130 :                         state->mode = BAD;
; 1131 :                         break;
; 1132 :                     }
; 1133 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1134 :                     Trace((stderr, "inflate.c too far\n"));
; 1135 :                     copy -= state->whave;
; 1136 :                     if (copy > state->length) copy = state->length;
; 1137 :                     if (copy > left) copy = left;
; 1138 :                     left -= copy;
; 1139 :                     state->length -= copy;
; 1140 :                     do {
; 1141 :                         *put++ = 0;
; 1142 :                     } while (--copy);
; 1143 :                     if (state->length == 0) state->mode = LEN;
; 1144 :                     break;
; 1145 : #endif
; 1146 :                 }
; 1147 :                 if (copy > state->wnext) {

  01357	41 8b 46 34	 mov	 eax, DWORD PTR [r14+52]
  0135b	3b c8		 cmp	 ecx, eax
  0135d	76 0a		 jbe	 SHORT $LN57@inflate

; 1148 :                     copy -= state->wnext;
; 1149 :                     from = state->window + (state->wsize - copy);

  0135f	41 8b 56 2c	 mov	 edx, DWORD PTR [r14+44]
  01363	2b c8		 sub	 ecx, eax
  01365	2b d1		 sub	 edx, ecx

; 1150 :                 }
; 1151 :                 else

  01367	eb 04		 jmp	 SHORT $LN801@inflate
$LN57@inflate:

; 1152 :                     from = state->window + (state->wnext - copy);

  01369	2b c1		 sub	 eax, ecx
  0136b	8b d0		 mov	 edx, eax
$LN801@inflate:

; 1153 :                 if (copy > state->length) copy = state->length;

  0136d	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]
  01371	49 03 56 38	 add	 rdx, QWORD PTR [r14+56]
  01375	3b c8		 cmp	 ecx, eax
  01377	76 0e		 jbe	 SHORT $LN54@inflate

; 1154 :             }
; 1155 :             else {                              /* copy from output */

  01379	eb 0a		 jmp	 SHORT $LN802@inflate
$LN60@inflate:

; 1156 :                 from = put - state->offset;
; 1157 :                 copy = state->length;

  0137b	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]
  0137f	49 8b d1	 mov	 rdx, r9
  01382	48 2b d1	 sub	 rdx, rcx
$LN802@inflate:
  01385	8b c8		 mov	 ecx, eax
$LN54@inflate:

; 1158 :             }
; 1159 :             if (copy > left) copy = left;

  01387	41 3b ca	 cmp	 ecx, r10d
  0138a	41 0f 47 ca	 cmova	 ecx, r10d

; 1160 :             left -= copy;

  0138e	44 2b d1	 sub	 r10d, ecx

; 1161 :             state->length -= copy;

  01391	2b c1		 sub	 eax, ecx

; 1164 :             } while (--copy);

  01393	49 2b d1	 sub	 rdx, r9
  01396	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  0139a	41 89 46 48	 mov	 DWORD PTR [r14+72], eax
  0139e	66 90		 npad	 2
$LL52@inflate:

; 1162 :             do {
; 1163 :                 *put++ = *from++;

  013a0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  013a5	49 ff c1	 inc	 r9

; 1164 :             } while (--copy);

  013a8	ff c9		 dec	 ecx
  013aa	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  013ae	75 f0		 jne	 SHORT $LL52@inflate

; 1165 :             if (state->length == 0) state->mode = LEN;

  013b0	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  013b4	41 39 4e 48	 cmp	 DWORD PTR [r14+72], ecx
  013b8	0f 85 21 f3 ff
	ff		 jne	 $LN490@inflate
  013be	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 1166 :             break;

  013c5	e9 15 f3 ff ff	 jmp	 $LN490@inflate
$LN48@inflate:

; 1167 :         case LIT:
; 1168 :             if (left == 0) goto inf_leave;

  013ca	45 85 d2	 test	 r10d, r10d
  013cd	0f 84 8a f4 ff
	ff		 je	 $LN765@inflate

; 1169 :             *put++ = (unsigned char)(state->length);

  013d3	41 0f b6 46 48	 movzx	 eax, BYTE PTR [r14+72]
  013d8	49 ff c1	 inc	 r9

; 1170 :             left--;

  013db	41 ff ca	 dec	 r10d
  013de	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  013e2	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  013e6	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9

; 1171 :             state->mode = LEN;

  013ea	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 1172 :             break;

  013f1	e9 e9 f2 ff ff	 jmp	 $LN490@inflate
$LN46@inflate:

; 1173 :         case CHECK:
; 1174 :             if (state->wrap) {

  013f6	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  013fb	0f 84 bc 00 00
	00		 je	 $LN31@inflate

; 1175 :                 NEEDBITS(32);

  01401	83 ff 20	 cmp	 edi, 32			; 00000020H
  01404	73 21		 jae	 SHORT $LN43@inflate
$LL41@inflate:
  01406	85 f6		 test	 esi, esi
  01408	0f 84 4f f4 ff
	ff		 je	 $LN765@inflate
  0140e	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  01413	8b cf		 mov	 ecx, edi
  01415	83 c7 08	 add	 edi, 8
  01418	d3 e0		 shl	 eax, cl
  0141a	ff ce		 dec	 esi
  0141c	49 ff c4	 inc	 r12
  0141f	44 03 e8	 add	 r13d, eax
  01422	83 ff 20	 cmp	 edi, 32			; 00000020H
  01425	72 df		 jb	 SHORT $LL41@inflate
$LN43@inflate:

; 1176 :                 out -= left;

  01427	45 2b c2	 sub	 r8d, r10d

; 1177 :                 strm->total_out += out;

  0142a	44 01 43 1c	 add	 DWORD PTR [rbx+28], r8d

; 1178 :                 state->total += out;

  0142e	45 01 46 1c	 add	 DWORD PTR [r14+28], r8d

; 1179 :                 if (out)

  01432	45 85 c0	 test	 r8d, r8d
  01435	74 2f		 je	 SHORT $LN35@inflate

; 1180 :                     strm->adler = state->check =
; 1181 :                         UPDATE(state->check, put - out, out);

  01437	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  0143b	41 8b c0	 mov	 eax, r8d
  0143e	49 8b d1	 mov	 rdx, r9
  01441	48 2b d0	 sub	 rdx, rax
  01444	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  01449	74 07		 je	 SHORT $LN504@inflate
  0144b	e8 00 00 00 00	 call	 crc32
  01450	eb 05		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  01452	e8 00 00 00 00	 call	 adler32
$LN505@inflate:
  01457	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0145b	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0145f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  01463	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN35@inflate:

; 1182 :                 out = left;
; 1183 :                 if ((
; 1184 : #ifdef GUNZIP
; 1185 :                      state->flags ? hold :
; 1186 : #endif
; 1187 :                      ZSWAP32(hold)) != state->check) {

  01466	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  0146b	44 89 55 b4	 mov	 DWORD PTR out$1$[rbp-128], r10d
  0146f	41 8b cd	 mov	 ecx, r13d
  01472	75 26		 jne	 SHORT $LN507@inflate
  01474	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0147a	41 8b c5	 mov	 eax, r13d
  0147d	c1 e0 10	 shl	 eax, 16
  01480	03 c8		 add	 ecx, eax
  01482	41 8b c5	 mov	 eax, r13d
  01485	c1 e8 08	 shr	 eax, 8
  01488	c1 e1 08	 shl	 ecx, 8
  0148b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01490	03 c8		 add	 ecx, eax
  01492	41 8b c5	 mov	 eax, r13d
  01495	c1 e8 18	 shr	 eax, 24
  01498	03 c8		 add	 ecx, eax
$LN507@inflate:
  0149a	41 3b 4e 18	 cmp	 ecx, DWORD PTR [r14+24]
  0149e	74 17		 je	 SHORT $LN33@inflate

; 1188 :                     strm->msg = (char *)"incorrect data check";

  014a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014a7	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  014ab	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  014b2	e9 28 f2 ff ff	 jmp	 $LN490@inflate
$LN33@inflate:

; 1189 :                     state->mode = BAD;
; 1190 :                     break;
; 1191 :                 }
; 1192 :                 INITBITS();

  014b7	45 8b ef	 mov	 r13d, r15d
  014ba	41 8b ff	 mov	 edi, r15d
$LN31@inflate:

; 1193 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1194 :             }
; 1195 : #ifdef GUNZIP
; 1196 :             state->mode = LENGTH;

  014bd	41 c7 06 1b 00
	00 00		 mov	 DWORD PTR [r14], 27
$LN30@inflate:

; 1197 :         case LENGTH:
; 1198 :             if (state->wrap && state->flags) {

  014c4	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  014c9	74 70		 je	 SHORT $LN16@inflate
  014cb	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  014d0	74 69		 je	 SHORT $LN16@inflate

; 1199 :                 NEEDBITS(32);

  014d2	83 ff 20	 cmp	 edi, 32			; 00000020H
  014d5	73 21		 jae	 SHORT $LN27@inflate
$LL25@inflate:
  014d7	85 f6		 test	 esi, esi
  014d9	0f 84 7e f3 ff
	ff		 je	 $LN765@inflate
  014df	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  014e4	8b cf		 mov	 ecx, edi
  014e6	83 c7 08	 add	 edi, 8
  014e9	d3 e0		 shl	 eax, cl
  014eb	ff ce		 dec	 esi
  014ed	49 ff c4	 inc	 r12
  014f0	44 03 e8	 add	 r13d, eax
  014f3	83 ff 20	 cmp	 edi, 32			; 00000020H
  014f6	72 df		 jb	 SHORT $LL25@inflate
$LN27@inflate:

; 1200 :                 if (hold != (state->total & 0xffffffffUL)) {

  014f8	45 3b 6e 1c	 cmp	 r13d, DWORD PTR [r14+28]
  014fc	74 37		 je	 SHORT $LN18@inflate

; 1201 :                     strm->msg = (char *)"incorrect length check";

  014fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  01505	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  01509	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  01510	e9 ca f1 ff ff	 jmp	 $LN490@inflate
$LN579@inflate:

; 820  :                 RESTORE();

  01515	4c 89 4b 10	 mov	 QWORD PTR [rbx+16], r9
  01519	44 89 53 18	 mov	 DWORD PTR [rbx+24], r10d
  0151d	4c 89 23	 mov	 QWORD PTR [rbx], r12
  01520	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 821  :                 return Z_NEED_DICT;

  01523	b8 02 00 00 00	 mov	 eax, 2
  01528	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  0152c	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  01530	e9 9a f3 ff ff	 jmp	 $LN798@inflate
$LN18@inflate:

; 1202 :                     state->mode = BAD;
; 1203 :                     break;
; 1204 :                 }
; 1205 :                 INITBITS();

  01535	45 8b ef	 mov	 r13d, r15d
  01538	41 8b ff	 mov	 edi, r15d
$LN16@inflate:

; 1206 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1207 :             }
; 1208 : #endif
; 1209 :             state->mode = DONE;

  0153b	41 c7 06 1c 00
	00 00		 mov	 DWORD PTR [r14], 28
$LN15@inflate:

; 1210 :         case DONE:
; 1211 :             ret = Z_STREAM_END;

  01542	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1212 :             goto inf_leave;

  01548	e9 14 f3 ff ff	 jmp	 $LN807@inflate
$LN14@inflate:

; 1213 :         case BAD:
; 1214 :             ret = Z_DATA_ERROR;

  0154d	41 bf fd ff ff
	ff		 mov	 r15d, -3
  01553	e9 09 f3 ff ff	 jmp	 $LN807@inflate
$LN5@inflate:

; 1236 :         }
; 1237 :     in -= strm->avail_in;
; 1238 :     out -= strm->avail_out;

  01558	2b 7b 18	 sub	 edi, DWORD PTR [rbx+24]
  0155b	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  0155f	44 2b 53 08	 sub	 r10d, DWORD PTR [rbx+8]

; 1239 :     strm->total_in += in;
; 1240 :     strm->total_out += out;

  01563	01 7b 1c	 add	 DWORD PTR [rbx+28], edi
  01566	44 01 53 0c	 add	 DWORD PTR [rbx+12], r10d

; 1241 :     state->total += out;

  0156a	41 01 7e 1c	 add	 DWORD PTR [r14+28], edi

; 1242 :     if (state->wrap && out)

  0156e	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  01573	44 89 55 bc	 mov	 DWORD PTR in$1$[rbp-128], r10d
  01577	74 32		 je	 SHORT $LN4@inflate
  01579	85 ff		 test	 edi, edi
  0157b	74 2e		 je	 SHORT $LN4@inflate

; 1243 :         strm->adler = state->check =
; 1244 :             UPDATE(state->check, strm->next_out - out, out);

  0157d	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  01581	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  01585	8b c7		 mov	 eax, edi
  01587	48 2b d0	 sub	 rdx, rax
  0158a	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  0158f	44 8b c7	 mov	 r8d, edi
  01592	74 07		 je	 SHORT $LN508@inflate
  01594	e8 00 00 00 00	 call	 crc32
  01599	eb 05		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  0159b	e8 00 00 00 00	 call	 adler32
$LN509@inflate:
  015a0	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  015a4	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  015a8	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN4@inflate:

; 1245 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1246 :                       (state->mode == TYPE ? 128 : 0) +
; 1247 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  015ab	41 8b 16	 mov	 edx, DWORD PTR [r14]
  015ae	83 fa 13	 cmp	 edx, 19
  015b1	74 0d		 je	 SHORT $LN510@inflate
  015b3	83 fa 0e	 cmp	 edx, 14
  015b6	74 08		 je	 SHORT $LN510@inflate
  015b8	45 33 c9	 xor	 r9d, r9d
  015bb	45 8b c1	 mov	 r8d, r9d
  015be	eb 09		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  015c0	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  015c6	45 33 c9	 xor	 r9d, r9d
$LN511@inflate:
  015c9	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  015cd	f7 d8		 neg	 eax
  015cf	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  015d4	1b c9		 sbb	 ecx, ecx
  015d6	83 e1 40	 and	 ecx, 64			; 00000040H
  015d9	83 fa 0b	 cmp	 edx, 11
  015dc	44 0f 44 c8	 cmove	 r9d, eax
  015e0	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  015e4	44 03 c8	 add	 r9d, eax
  015e7	45 03 4e 44	 add	 r9d, DWORD PTR [r14+68]
  015eb	44 89 4b 48	 mov	 DWORD PTR [rbx+72], r9d

; 1248 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  015ef	45 85 d2	 test	 r10d, r10d
  015f2	75 04		 jne	 SHORT $LN1@inflate
  015f4	85 ff		 test	 edi, edi
  015f6	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  015f8	83 7d 28 04	 cmp	 DWORD PTR flush$[rbp-128], 4
  015fc	75 0c		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  015fe	b8 fb ff ff ff	 mov	 eax, -5
  01603	45 85 ff	 test	 r15d, r15d
  01606	44 0f 44 f8	 cmove	 r15d, eax
$LN3@inflate:

; 1249 :         ret = Z_BUF_ERROR;
; 1250 :     return ret;

  0160a	41 8b c7	 mov	 eax, r15d
  0160d	e9 bd f2 ff ff	 jmp	 $LN798@inflate
$LN12@inflate:

; 1215 :             goto inf_leave;
; 1216 :         case MEM:
; 1217 :             return Z_MEM_ERROR;
; 1218 :         case SYNC:
; 1219 :         default:
; 1220 :             return Z_STREAM_ERROR;

  01612	b8 fe ff ff ff	 mov	 eax, -2
  01617	e9 b3 f2 ff ff	 jmp	 $LN798@inflate
$LN498@inflate:

; 629  :         return Z_STREAM_ERROR;

  0161c	b8 fe ff ff ff	 mov	 eax, -2

; 1251 : }

  01621	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  01628	41 5e		 pop	 r14
  0162a	5b		 pop	 rbx
  0162b	5d		 pop	 rbp
  0162c	c3		 ret	 0
  0162d	0f 1f 00	 npad	 3
$LN671@inflate:
  01630	00 00 00 00	 DD	 $LN489@inflate
  01634	00 00 00 00	 DD	 $LN457@inflate
  01638	00 00 00 00	 DD	 $LN437@inflate
  0163c	00 00 00 00	 DD	 $LN419@inflate
  01640	00 00 00 00	 DD	 $LN402@inflate
  01644	00 00 00 00	 DD	 $LN381@inflate
  01648	00 00 00 00	 DD	 $LN374@inflate
  0164c	00 00 00 00	 DD	 $LN362@inflate
  01650	00 00 00 00	 DD	 $LN350@inflate
  01654	00 00 00 00	 DD	 $LN333@inflate
  01658	00 00 00 00	 DD	 $LN321@inflate
  0165c	00 00 00 00	 DD	 $LN316@inflate
  01660	00 00 00 00	 DD	 $LN315@inflate
  01664	00 00 00 00	 DD	 $LN282@inflate
  01668	00 00 00 00	 DD	 $LN266@inflate
  0166c	00 00 00 00	 DD	 $LN264@inflate
  01670	00 00 00 00	 DD	 $LN258@inflate
  01674	00 00 00 00	 DD	 $LN525@inflate
  01678	00 00 00 00	 DD	 $LN528@inflate
  0167c	00 00 00 00	 DD	 $LN148@inflate
  01680	00 00 00 00	 DD	 $LN146@inflate
  01684	00 00 00 00	 DD	 $LN113@inflate
  01688	00 00 00 00	 DD	 $LN537@inflate
  0168c	00 00 00 00	 DD	 $LN76@inflate
  01690	00 00 00 00	 DD	 $LN62@inflate
  01694	00 00 00 00	 DD	 $LN48@inflate
  01698	00 00 00 00	 DD	 $LN46@inflate
  0169c	00 00 00 00	 DD	 $LN30@inflate
  016a0	00 00 00 00	 DD	 $LN15@inflate
  016a4	00 00 00 00	 DD	 $LN14@inflate
  016a8	00 00 00 00	 DD	 $LN13@inflate
inflate	ENDP
_TEXT	ENDS
PUBLIC	inflateReset
; Function compile flags: /Ogtpy
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 8
inflateReset PROC					; COMDAT

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 17		 je	 SHORT $LN1@inflateRes@2
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 0e		 je	 SHORT $LN1@inflateRes@2

; 134  :     state = (struct inflate_state FAR *)strm->state;
; 135  :     state->wsize = 0;

  0000e	33 d2		 xor	 edx, edx
  00010	48 89 50 2c	 mov	 QWORD PTR [rax+44], rdx

; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;

  00014	89 50 34	 mov	 DWORD PTR [rax+52], edx

; 138  :     return inflateResetKeep(strm);
; 139  : }

  00017	e9 00 00 00 00	 jmp	 inflateResetKeep
$LN1@inflateRes@2:

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2

; 138  :     return inflateResetKeep(strm);
; 139  : }

  00021	c3		 ret	 0
inflateReset ENDP
PUBLIC	inflateSync
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN12+66
	DD	imagerel $LN12+204
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSync DD imagerel $LN12+204
	DD	imagerel $LN12+275
	DD	imagerel $chain$1$inflateSync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSync DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	073405H
	DD	imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateSync
_TEXT	SEGMENT
buf$ = 48
strm$ = 48
inflateSync PROC					; COMDAT

; 1363 : {

$LN12:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 1364 :     unsigned len;               /* number of bytes to look at or looked at */
; 1365 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1366 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1367 :     struct inflate_state FAR *state;
; 1368 : 
; 1369 :     /* check parameters */
; 1370 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 ed 00 00
	00		 je	 $LN6@inflateSyn@2
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 e0 00 00
	00		 je	 $LN6@inflateSyn@2

; 1371 :     state = (struct inflate_state FAR *)strm->state;
; 1372 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00023	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00027	75 16		 jne	 SHORT $LN5@inflateSyn@2
  00029	83 7f 44 08	 cmp	 DWORD PTR [rdi+68], 8
  0002d	73 10		 jae	 SHORT $LN5@inflateSyn@2
  0002f	b8 fb ff ff ff	 mov	 eax, -5

; 1402 : }

  00034	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateSyn@2:

; 1373 : 
; 1374 :     /* if first time, start search in bit buffer */
; 1375 :     if (state->mode != SYNC) {

  0003f	83 3f 1f	 cmp	 DWORD PTR [rdi], 31
  00042	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00047	74 59		 je	 SHORT $LN4@inflateSyn@2

; 1376 :         state->mode = SYNC;
; 1377 :         state->hold <<= state->bits & 7;

  00049	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]

; 1378 :         state->bits -= state->bits & 7;
; 1379 :         len = 0;

  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	c7 07 1f 00 00
	00		 mov	 DWORD PTR [rdi], 31
  00055	8b ca		 mov	 ecx, edx
  00057	83 e1 07	 and	 ecx, 7
  0005a	d3 67 40	 shl	 DWORD PTR [rdi+64], cl
  0005d	2b d1		 sub	 edx, ecx
  0005f	89 57 44	 mov	 DWORD PTR [rdi+68], edx

; 1380 :         while (state->bits >= 8) {

  00062	83 fa 08	 cmp	 edx, 8
  00065	72 27		 jb	 SHORT $LN2@inflateSyn@2
  00067	8b 4f 40	 mov	 ecx, DWORD PTR [rdi+64]
  0006a	4c 8d 4c 24 30	 lea	 r9, QWORD PTR buf$[rsp]
  0006f	90		 npad	 1
$LL3@inflateSyn@2:

; 1381 :             buf[len++] = (unsigned char)(state->hold);

  00070	0f b6 47 40	 movzx	 eax, BYTE PTR [rdi+64]

; 1382 :             state->hold >>= 8;
; 1383 :             state->bits -= 8;

  00074	83 c2 f8	 add	 edx, -8			; fffffff8H
  00077	c1 e9 08	 shr	 ecx, 8
  0007a	41 88 01	 mov	 BYTE PTR [r9], al
  0007d	49 ff c1	 inc	 r9
  00080	41 ff c0	 inc	 r8d
  00083	89 4f 40	 mov	 DWORD PTR [rdi+64], ecx
  00086	89 57 44	 mov	 DWORD PTR [rdi+68], edx
  00089	83 fa 08	 cmp	 edx, 8
  0008c	73 e2		 jae	 SHORT $LL3@inflateSyn@2
$LN2@inflateSyn@2:

; 1384 :         }
; 1385 :         state->have = 0;

  0008e	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]

; 1386 :         syncsearch(&(state->have), buf, len);

  00092	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00097	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  0009d	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn@2:

; 1387 :     }
; 1388 : 
; 1389 :     /* search available input */
; 1390 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000a2	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000a6	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000a9	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]
  000ad	e8 00 00 00 00	 call	 syncsearch
  000b2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 1391 :     strm->avail_in -= len;
; 1392 :     strm->next_in += len;
; 1393 :     strm->total_in += len;

  000b7	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000ba	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000bd	44 8b 56 0c	 mov	 r10d, DWORD PTR [rsi+12]
  000c1	8b c8		 mov	 ecx, eax
  000c3	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1394 : 
; 1395 :     /* return no joy or set up to restart inflate() on a new block */
; 1396 :     if (state->have != 4) return Z_DATA_ERROR;

  000c6	83 7f 7c 04	 cmp	 DWORD PTR [rdi+124], 4
  000ca	74 10		 je	 SHORT $LN1@inflateSyn@2
  000cc	b8 fd ff ff ff	 mov	 eax, -3

; 1402 : }

  000d1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
$LN1@inflateSyn@2:

; 1397 :     in = strm->total_in;  out = strm->total_out;

  000dc	44 8b 4e 1c	 mov	 r9d, DWORD PTR [rsi+28]

; 1398 :     inflateReset(strm);

  000e0	48 8b ce	 mov	 rcx, rsi
  000e3	e8 00 00 00 00	 call	 inflateReset

; 1399 :     strm->total_in = in;  strm->total_out = out;

  000e8	44 89 56 0c	 mov	 DWORD PTR [rsi+12], r10d
  000ec	44 89 4e 1c	 mov	 DWORD PTR [rsi+28], r9d

; 1400 :     state->mode = TYPE;

  000f0	c7 07 0b 00 00
	00		 mov	 DWORD PTR [rdi], 11

; 1401 :     return Z_OK;

  000f6	33 c0		 xor	 eax, eax

; 1402 : }

  000f8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
$LN6@inflateSyn@2:

; 1364 :     unsigned len;               /* number of bytes to look at or looked at */
; 1365 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1366 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1367 :     struct inflate_state FAR *state;
; 1368 : 
; 1369 :     /* check parameters */
; 1370 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00103	b8 fe ff ff ff	 mov	 eax, -2

; 1402 : }

  00108	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
PUBLIC	inflateReset2
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateReset2 DD imagerel $LN12+34
	DD	imagerel $LN12+104
	DD	imagerel $chain$0$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateReset2 DD imagerel $LN12+104
	DD	imagerel $LN12+149
	DD	imagerel $chain$2$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateReset2 DD imagerel $LN12+149
	DD	imagerel $LN12+170
	DD	imagerel $chain$3$inflateReset2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateReset2 DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateReset2 DD 020021H
	DD	065400H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateReset2 DD 020521H
	DD	065405H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 144  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b da		 mov	 ebx, edx
  00011	48 8b f1	 mov	 rsi, rcx

; 145  :     int wrap;
; 146  :     struct inflate_state FAR *state;
; 147  : 
; 148  :     /* get the state */
; 149  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00014	48 85 c9	 test	 rcx, rcx
  00017	74 7c		 je	 SHORT $LN7@inflateRes@3
  00019	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001d	48 85 ff	 test	 rdi, rdi
  00020	74 73		 je	 SHORT $LN7@inflateRes@3

; 150  :     state = (struct inflate_state FAR *)strm->state;
; 151  : 
; 152  :     /* extract wrap request from windowBits parameter */
; 153  :     if (windowBits < 0) {

  00022	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00027	85 d2		 test	 edx, edx
  00029	79 06		 jns	 SHORT $LN6@inflateRes@3

; 154  :         wrap = 0;

  0002b	33 ed		 xor	 ebp, ebp

; 155  :         windowBits = -windowBits;

  0002d	f7 db		 neg	 ebx

; 156  :     }
; 157  :     else {

  0002f	eb 0f		 jmp	 SHORT $LN4@inflateRes@3
$LN6@inflateRes@3:

; 158  :         wrap = (windowBits >> 4) + 1;

  00031	8b ea		 mov	 ebp, edx
  00033	c1 fd 04	 sar	 ebp, 4
  00036	ff c5		 inc	 ebp

; 159  : #ifdef GUNZIP
; 160  :         if (windowBits < 48)

  00038	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN4@inflateRes@3

; 161  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN4@inflateRes@3:

; 162  : #endif
; 163  :     }
; 164  : 
; 165  :     /* set number of window bits, free window if different */
; 166  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00040	85 db		 test	 ebx, ebx
  00042	74 24		 je	 SHORT $LN3@inflateRes@3
  00044	83 fb 08	 cmp	 ebx, 8
  00047	7c 05		 jl	 SHORT $LN2@inflateRes@3
  00049	83 fb 0f	 cmp	 ebx, 15
  0004c	7e 1a		 jle	 SHORT $LN3@inflateRes@3
$LN2@inflateRes@3:

; 167  :         return Z_STREAM_ERROR;

  0004e	b8 fe ff ff ff	 mov	 eax, -2
$LN11@inflateRes@3:
  00053	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 177  : }

  00058	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN3@inflateRes@3:

; 168  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00068	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0006c	48 85 d2	 test	 rdx, rdx
  0006f	74 14		 je	 SHORT $LN1@inflateRes@3
  00071	39 5f 28	 cmp	 DWORD PTR [rdi+40], ebx
  00074	74 0f		 je	 SHORT $LN1@inflateRes@3

; 169  :         ZFREE(strm, state->window);

  00076	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0007a	ff 56 38	 call	 QWORD PTR [rsi+56]

; 170  :         state->window = Z_NULL;

  0007d	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$LN1@inflateRes@3:

; 171  :     }
; 172  : 
; 173  :     /* update state and reset the rest of it */
; 174  :     state->wrap = wrap;
; 175  :     state->wbits = (unsigned)windowBits;
; 176  :     return inflateReset(strm);

  00085	48 8b ce	 mov	 rcx, rsi
  00088	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp
  0008b	89 5f 28	 mov	 DWORD PTR [rdi+40], ebx
  0008e	e8 00 00 00 00	 call	 inflateReset
  00093	eb be		 jmp	 SHORT $LN11@inflateRes@3
$LN7@inflateRes@3:

; 177  : }

  00095	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0009a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009f	b8 fe ff ff ff	 mov	 eax, -2
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
inflateReset2 ENDP
PUBLIC	inflateInit2_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN12+63
	DD	imagerel $LN12+172
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN12+172
	DD	imagerel $LN12+214
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN12+214
	DD	imagerel $LN12+230
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07640cH
	DD	065405H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 184  : {

$LN12:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 185  :     int ret;
; 186  :     struct inflate_state FAR *state;
; 187  : 
; 188  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 189  :         stream_size != (int)(sizeof(z_stream)))

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 be 00 00
	00		 je	 $LN6@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 b4 00 00
	00		 jne	 $LN6@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 aa 00 00
	00		 jne	 $LN6@inflateIni

; 191  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN5@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 219  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateIni:
  0003f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 192  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0004b	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp

; 193  :     if (strm->zalloc == (alloc_func)0) {

  0004f	48 39 69 30	 cmp	 QWORD PTR [rcx+48], rbp
  00053	75 0f		 jne	 SHORT $LN4@inflateIni

; 194  : #ifdef Z_SOLO
; 195  :         return Z_STREAM_ERROR;
; 196  : #else
; 197  :         strm->zalloc = zcalloc;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 198  :         strm->opaque = (voidpf)0;

  0005c	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00060	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN4@inflateIni:

; 199  : #endif
; 200  :     }
; 201  :     if (strm->zfree == (free_func)0)

  00064	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree

; 202  : #ifdef Z_SOLO
; 203  :         return Z_STREAM_ERROR;
; 204  : #else
; 205  :         strm->zfree = zcfree;
; 206  : #endif
; 207  :     state = (struct inflate_state FAR *)
; 208  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  0006f	ba 01 00 00 00	 mov	 edx, 1
  00074	48 3b c5	 cmp	 rax, rbp
  00077	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  0007d	48 0f 44 c1	 cmove	 rax, rcx
  00081	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00085	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00089	ff 53 30	 call	 QWORD PTR [rbx+48]
  0008c	48 8b f0	 mov	 rsi, rax

; 209  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0008f	48 85 c0	 test	 rax, rax
  00092	75 18		 jne	 SHORT $LN2@inflateIni
  00094	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
$LN11@inflateIni:
  00097	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 219  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN2@inflateIni:

; 210  :     Tracev((stderr, "inflate: allocated\n"));
; 211  :     strm->state = (struct internal_state FAR *)state;

  000ac	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 212  :     state->window = Z_NULL;
; 213  :     ret = inflateReset2(strm, windowBits);

  000b0	8b d7		 mov	 edx, edi
  000b2	48 8b cb	 mov	 rcx, rbx
  000b5	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000b9	e8 00 00 00 00	 call	 inflateReset2
  000be	8b f8		 mov	 edi, eax

; 214  :     if (ret != Z_OK) {

  000c0	85 c0		 test	 eax, eax
  000c2	74 0e		 je	 SHORT $LN1@inflateIni

; 215  :         ZFREE(strm, state);

  000c4	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c8	48 8b d6	 mov	 rdx, rsi
  000cb	ff 53 38	 call	 QWORD PTR [rbx+56]

; 216  :         strm->state = Z_NULL;

  000ce	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN1@inflateIni:

; 217  :     }
; 218  :     return ret;

  000d2	8b c7		 mov	 eax, edi
  000d4	eb c1		 jmp	 SHORT $LN11@inflateIni
$LN6@inflateIni:

; 190  :         return Z_VERSION_ERROR;

  000d6	b8 fa ff ff ff	 mov	 eax, -6

; 219  : }

  000db	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
inflateInit2_ ENDP
PUBLIC	inflateInit_
; Function compile flags: /Ogtpy
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 226  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15

; 227  : }

  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
END
